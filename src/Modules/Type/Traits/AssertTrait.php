<?php

/**
 * This class is autogenerated.
 */

namespace Gzhegow\Lib\Modules\Type\Traits;

use Gzhegow\Lib\Exception\LogicException;
use Gzhegow\Lib\Lib;
use Gzhegow\Lib\Modules\Arr\ArrPath;
use Gzhegow\Lib\Modules\Bcmath\Bcnumber;
use Gzhegow\Lib\Modules\Bcmath\Number;
use Gzhegow\Lib\Modules\Net\AddressIpV4;
use Gzhegow\Lib\Modules\Net\AddressIpV6;
use Gzhegow\Lib\Modules\Net\SubnetV4;
use Gzhegow\Lib\Modules\Net\SubnetV6;
use Gzhegow\Lib\Modules\Php\Nil;
use Gzhegow\Lib\Modules\Str\Alphabet;

trait AssertTrait
{
	/**
	 * @return mixed
	 */
	public function assert_empty($value)
	{
		if (Lib::php()->type_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `empty` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_empty($value)
	{
		if (Lib::php()->type_any_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 *
	 * @return string|array|\Countable|null
	 */
	public function assert_blank($value)
	{
		if (Lib::php()->type_blank($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `blank` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_blank($value)
	{
		if (Lib::php()->type_any_not_blank($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_blank` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 *
	 * @return mixed
	 */
	public function assert_nullable($value)
	{
		if (Lib::php()->type_nullable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `nullable` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_nullable($value)
	{
		if (Lib::php()->type_any_not_nullable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_nullable` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 *
	 * @return mixed
	 */
	public function assert_passed($value)
	{
		if (Lib::php()->type_passed($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `passed` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_passed($value)
	{
		if (Lib::php()->type_any_not_passed($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_passed` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 *
	 * @return string|Nil
	 */
	public function assert_nil($value)
	{
		if (Lib::php()->type_nil($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `nil` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_nil($value)
	{
		if (Lib::php()->type_any_not_nil($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_nil` is failed', [ $value ] ]);
	}


	/**
	 * @return null
	 */
	public function assert_null($value)
	{
		if (Lib::php()->type_null($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `null` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_null($value)
	{
		if (Lib::php()->type_any_not_null($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_null` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_false($value)
	{
		if (Lib::php()->type_false($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `false` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_false($value)
	{
		if (Lib::php()->type_any_not_false($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_false` is failed', [ $value ] ]);
	}


	/**
	 * @return true
	 */
	public function assert_true($value)
	{
		if (Lib::php()->type_true($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `true` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_true($value)
	{
		if (Lib::php()->type_any_not_true($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_true` is failed', [ $value ] ]);
	}


	/**
	 * @return bool
	 */
	public function assert_bool($value)
	{
		if (Lib::php()->type_bool($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `bool` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_boolfalse($value)
	{
		if (Lib::php()->type_boolfalse($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `boolfalse` is failed', [ $value ] ]);
	}


	/**
	 * @return true
	 */
	public function assert_booltrue($value)
	{
		if (Lib::php()->type_booltrue($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `booltrue` is failed', [ $value ] ]);
	}


	/**
	 * @return bool
	 */
	public function assert_userbool($value)
	{
		if (Lib::php()->type_userbool($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `userbool` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_userfalse($value)
	{
		if (Lib::php()->type_userfalse($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `userfalse` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_usertrue($value)
	{
		if (Lib::php()->type_usertrue($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `usertrue` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array($value)
	{
		if (Lib::php()->type_array($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_empty($value)
	{
		if (Lib::php()->type_array_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_not_empty($value)
	{
		if (Lib::php()->type_array_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_array_empty($value)
	{
		if (Lib::php()->type_any_not_array_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_array_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_array($value)
	{
		if (Lib::php()->type_any_not_array($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_array` is failed', [ $value ] ]);
	}


	/**
	 * @return object
	 */
	public function assert_object($value)
	{
		if (Lib::php()->type_object($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `object` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_object($value)
	{
		if (Lib::php()->type_any_not_object($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_object` is failed', [ $value ] ]);
	}


	/**
	 * @return \stdClass
	 */
	public function assert_stdclass($value)
	{
		if (Lib::php()->type_stdclass($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `stdclass` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_stdclass($value)
	{
		if (Lib::php()->type_any_not_stdclass($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_stdclass` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_nan($value)
	{
		if (Lib::num()->type_nan($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `nan` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_nan($value)
	{
		if (Lib::num()->type_float_not_nan($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_nan` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_nan($value)
	{
		if (Lib::num()->type_any_not_nan($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_nan` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_finite($value)
	{
		if (Lib::num()->type_finite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `finite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_finite($value)
	{
		if (Lib::num()->type_float_not_finite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_finite` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_finite($value)
	{
		if (Lib::num()->type_any_not_finite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_finite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_infinite($value)
	{
		if (Lib::num()->type_infinite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `infinite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_infinite($value)
	{
		if (Lib::num()->type_float_not_infinite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_infinite` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_infinite($value)
	{
		if (Lib::num()->type_any_not_infinite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_infinite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_min($value)
	{
		if (Lib::num()->type_float_min($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_min` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_float_min($value)
	{
		if (Lib::num()->type_float_not_float_min($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_float_min` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_float_min($value)
	{
		if (Lib::num()->type_any_not_float_min($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_float_min` is failed', [ $value ] ]);
	}


	/**
	 * @return Number
	 */
	public function assert_number($value, ?bool $isAllowExp = null)
	{
		if (Lib::num()->type_number($value, $isAllowExp)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `number` is failed', [ $value, $isAllowExp ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (Lib::num()->type_numeric($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_non_zero($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (Lib::num()->type_numeric_non_zero($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_non_zero` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_non_negative($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (Lib::num()->type_numeric_non_negative($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_non_negative` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_non_positive($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (Lib::num()->type_numeric_non_positive($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_non_positive` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_negative($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (Lib::num()->type_numeric_negative($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_negative` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_positive($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (Lib::num()->type_numeric_positive($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_positive` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_zero($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_non_zero($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_zero` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_negative($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_non_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_positive($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_non_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_negative($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_positive($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_positive_or_minus_one($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_positive_or_minus_one($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_positive_or_minus_one` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_negative_or_minus_one($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_int_non_negative_or_minus_one($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_negative_or_minus_one` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_float($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_non_zero($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_float_non_zero($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_non_zero` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_non_negative($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_float_non_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_non_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_non_positive($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_float_non_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_non_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_negative($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_float_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_positive($value, array $refs = [])
	{
		if (Lib::num()->type_numeric_float_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (Lib::num()->type_numeric_trimpad($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_non_zero(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (Lib::num()->type_numeric_trimpad_non_zero($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_non_zero` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_non_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (Lib::num()->type_numeric_trimpad_non_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_non_negative` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_non_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (Lib::num()->type_numeric_trimpad_non_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_non_positive` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (Lib::num()->type_numeric_trimpad_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_negative` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (Lib::num()->type_numeric_trimpad_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_positive` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal($value, int $scale = 0, array $refs = [])
	{
		if (Lib::num()->type_decimal($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_non_zero($value, int $scale = 0, array $refs = [])
	{
		if (Lib::num()->type_decimal_non_zero($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_non_zero` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_non_negative($value, int $scale = 0, array $refs = [])
	{
		if (Lib::num()->type_decimal_non_negative($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_non_negative` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_non_positive($value, int $scale = 0, array $refs = [])
	{
		if (Lib::num()->type_decimal_non_positive($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_non_positive` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_negative($value, int $scale = 0, array $refs = [])
	{
		if (Lib::num()->type_decimal_negative($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_negative` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_positive($value, int $scale = 0, array $refs = [])
	{
		if (Lib::num()->type_decimal_positive($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_positive` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num($value)
	{
		if (Lib::num()->type_num($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_non_zero($value)
	{
		if (Lib::num()->type_num_non_zero($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_non_zero` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_non_negative($value)
	{
		if (Lib::num()->type_num_non_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_non_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_non_positive($value)
	{
		if (Lib::num()->type_num_non_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_non_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_negative($value)
	{
		if (Lib::num()->type_num_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_positive($value)
	{
		if (Lib::num()->type_num_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int($value)
	{
		if (Lib::num()->type_int($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_zero($value)
	{
		if (Lib::num()->type_int_non_zero($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_zero` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_negative($value)
	{
		if (Lib::num()->type_int_non_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_positive($value)
	{
		if (Lib::num()->type_int_non_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_negative($value)
	{
		if (Lib::num()->type_int_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_positive($value)
	{
		if (Lib::num()->type_int_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_positive_or_minus_one($value)
	{
		if (Lib::num()->type_int_positive_or_minus_one($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_positive_or_minus_one` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_negative_or_minus_one($value)
	{
		if (Lib::num()->type_int_non_negative_or_minus_one($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_negative_or_minus_one` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float($value)
	{
		if (Lib::num()->type_float($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_non_zero($value)
	{
		if (Lib::num()->type_float_non_zero($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_non_zero` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_non_negative($value)
	{
		if (Lib::num()->type_float_non_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_non_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_non_positive($value)
	{
		if (Lib::num()->type_float_non_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_non_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_negative($value)
	{
		if (Lib::num()->type_float_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_positive($value)
	{
		if (Lib::num()->type_float_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return Bcnumber
	 */
	public function assert_bcnumber($value)
	{
		if (Lib::bcmath()->type_bcnumber($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `bcnumber` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_string($value)
	{
		if (Lib::str()->type_a_string($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_string` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_string_empty($value)
	{
		if (Lib::str()->type_a_string_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_string_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_string_not_empty($value)
	{
		if (Lib::str()->type_a_string_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_string_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_trim($value)
	{
		if (Lib::str()->type_a_trim($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_trim` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_string($value)
	{
		if (Lib::str()->type_string($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `string` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_string_empty($value)
	{
		if (Lib::str()->type_string_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `string_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_string_not_empty($value)
	{
		if (Lib::str()->type_string_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `string_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_trim($value, ?string $characters = null)
	{
		if (Lib::str()->type_trim($value, $characters)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `trim` is failed', [ $value, $characters ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_char($value)
	{
		if (Lib::str()->type_char($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `char` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_letter($value)
	{
		if (Lib::str()->type_letter($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `letter` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_word($value)
	{
		if (Lib::str()->type_word($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `word` is failed', [ $value ] ]);
	}


	/**
	 * @return Alphabet
	 */
	public function assert_alphabet($value)
	{
		if (Lib::str()->type_alphabet($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `alphabet` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_ctype_digit($value)
	{
		if (Lib::str()->type_ctype_digit($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `ctype_digit` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_ctype_alpha($value, ?bool $allowUpperCase = null)
	{
		if (Lib::str()->type_ctype_alpha($value, $allowUpperCase)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `ctype_alpha` is failed', [ $value, $allowUpperCase ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_ctype_alnum($value, ?bool $allowUpperCase = null)
	{
		if (Lib::str()->type_ctype_alnum($value, $allowUpperCase)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `ctype_alnum` is failed', [ $value, $allowUpperCase ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base($value, $alphabet)
	{
		if (Lib::crypt()->type_base($value, $alphabet)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base` is failed', [ $value, $alphabet ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_bin($value)
	{
		if (Lib::crypt()->type_base_bin($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_bin` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_oct($value)
	{
		if (Lib::crypt()->type_base_oct($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_oct` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_dec($value)
	{
		if (Lib::crypt()->type_base_dec($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_dec` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_hex($value)
	{
		if (Lib::crypt()->type_base_hex($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_hex` is failed', [ $value ] ]);
	}


	/**
	 * @return int|string
	 */
	public function assert_key($key)
	{
		if (Lib::arr()->type_key($key)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `key` is failed', [ $key ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_key_exists($key, array $array)
	{
		if (Lib::arr()->type_key_exists($key, $array)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `key_exists` is failed', [ $key, $array ] ]);
	}


	/**
	 * @return null
	 */
	public function assert_key_not_exists($key, array $array)
	{
		if (Lib::arr()->type_key_not_exists($key, $array)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `key_not_exists` is failed', [ $key, $array ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_plain($value, ?int $maxDepth = null)
	{
		if (Lib::arr()->type_array_plain($value, $maxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_plain` is failed', [ $value, $maxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_list($value, ?int $plainMaxDepth = null)
	{
		if (Lib::arr()->type_list($value, $plainMaxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `list` is failed', [ $value, $plainMaxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_list_sorted($value, ?int $plainMaxDepth = null)
	{
		if (Lib::arr()->type_list_sorted($value, $plainMaxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `list_sorted` is failed', [ $value, $plainMaxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_dict($value, ?int $plainMaxDepth = null)
	{
		if (Lib::arr()->type_dict($value, $plainMaxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dict` is failed', [ $value, $plainMaxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_dict_sorted($value, ?int $plainMaxDepth = null, $fnSortCmp = null)
	{
		if (Lib::arr()->type_dict_sorted($value, $plainMaxDepth, $fnSortCmp)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dict_sorted` is failed', [ $value, $plainMaxDepth, $fnSortCmp ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_table($value)
	{
		if (Lib::arr()->type_table($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `table` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_matrix($value)
	{
		if (Lib::arr()->type_matrix($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `matrix` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_matrix_strict($value)
	{
		if (Lib::arr()->type_matrix_strict($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `matrix_strict` is failed', [ $value ] ]);
	}


	/**
	 * @return ArrPath
	 */
	public function assert_arrpath($path)
	{
		if (Lib::arr()->type_arrpath($path)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `arrpath` is failed', [ $path ] ]);
	}


	/**
	 * @return ArrPath
	 */
	public function assert_arrpath_dot($path, ?string $dot = '.')
	{
		if (Lib::arr()->type_arrpath_dot($path, $dot)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `arrpath_dot` is failed', [ $path, $dot ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_of_type($value, string $type)
	{
		if (Lib::arr()->type_array_of_type($value, $type)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_type` is failed', [ $value, $type ] ]);
	}


	/**
	 * @return resource[]
	 */
	public function assert_array_of_resource_type($value, string $resourceType)
	{
		if (Lib::arr()->type_array_of_resource_type($value, $resourceType)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_resource_type` is failed', [ $value, $resourceType ] ]);
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 *
	 * @return T[]
	 */
	public function assert_array_of_a($value, string $className)
	{
		if (Lib::arr()->type_array_of_a($value, $className)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_a` is failed', [ $value, $className ] ]);
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 *
	 * @return T[]
	 */
	public function assert_array_of_class($value, string $className)
	{
		if (Lib::arr()->type_array_of_class($value, $className)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_class` is failed', [ $value, $className ] ]);
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 *
	 * @return T[]
	 */
	public function assert_array_of_subclass($value, string $className)
	{
		if (Lib::arr()->type_array_of_subclass($value, $className)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_subclass` is failed', [ $value, $className ] ]);
	}


	/**
	 * @param callable $fn
	 *
	 * @noinspection PhpDocSignatureIsNotCompleteInspection
	 *
	 * @return array
	 */
	public function assert_array_of_callback($value, callable $fn, array $args = [])
	{
		if (Lib::arr()->type_array_of_callback($value, $fn, $args)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_callback` is failed', [ $value, $fn, $args ] ]);
	}


	/**
	 * @return array{ 0: string, 1: int }
	 */
	public function assert_fileline($value)
	{
		if (Lib::debug()->type_fileline($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `fileline` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_html_tag($value)
	{
		if (Lib::format()->type_html_tag($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `html_tag` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_xml_tag($value)
	{
		if (Lib::format()->type_xml_tag($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `xml_tag` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_xml_nstag($value)
	{
		if (Lib::format()->type_xml_nstag($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `xml_nstag` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_regex($value)
	{
		if (Lib::preg()->type_regex($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `regex` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_regexp($value)
	{
		if (Lib::preg()->type_regexp($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `regexp` is failed', [ $value ] ]);
	}


	/**
	 * @return AddressIpV4|AddressIpV6
	 */
	public function assert_address_ip($value)
	{
		if (Lib::net()->type_address_ip($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_ip` is failed', [ $value ] ]);
	}


	/**
	 * @return AddressIpV4
	 */
	public function assert_address_ip_v4($value)
	{
		if (Lib::net()->type_address_ip_v4($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_ip_v4` is failed', [ $value ] ]);
	}


	/**
	 * @return AddressIpV6
	 */
	public function assert_address_ip_v6($value)
	{
		if (Lib::net()->type_address_ip_v6($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_ip_v6` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_address_mac($value)
	{
		if (Lib::net()->type_address_mac($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_mac` is failed', [ $value ] ]);
	}


	/**
	 * @return SubnetV4|SubnetV6
	 */
	public function assert_subnet($value, ?string $ipFallback = null)
	{
		if (Lib::net()->type_subnet($value, $ipFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `subnet` is failed', [ $value, $ipFallback ] ]);
	}


	/**
	 * @return SubnetV4
	 */
	public function assert_subnet_v4($value, ?string $ipFallback = null)
	{
		if (Lib::net()->type_subnet_v4($value, $ipFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `subnet_v4` is failed', [ $value, $ipFallback ] ]);
	}


	/**
	 * @return SubnetV6
	 */
	public function assert_subnet_v6($value, ?string $ipFallback = null)
	{
		if (Lib::net()->type_subnet_v6($value, $ipFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `subnet_v6` is failed', [ $value, $ipFallback ] ]);
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 *
	 * @return string
	 */
	public function assert_url(
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	) {
		if (Lib::url()->type_url($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `url` is failed', [ $value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs ] ]);
	}


	/**
	 * @param string|true $value
	 *
	 * @return string
	 */
	public function assert_host($value, ?int $isHostIdnaAscii = null, array $refs = [])
	{
		if (Lib::url()->type_host($value, $isHostIdnaAscii, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `host` is failed', [ $value, $isHostIdnaAscii, $refs ] ]);
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 *
	 * @return string
	 */
	public function assert_link($value, $query = null, $fragment = null, ?int $isLinkUrlencoded = null, array $refs = [])
	{
		if (Lib::url()->type_link($value, $query, $fragment, $isLinkUrlencoded, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `link` is failed', [ $value, $query, $fragment, $isLinkUrlencoded, $refs ] ]);
	}


	/**
	 * @param string $value
	 *
	 * @return string
	 */
	public function assert_dsn_pdo($value, array $refs = [])
	{
		if (Lib::url()->type_dsn_pdo($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dsn_pdo` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_uuid($value)
	{
		if (Lib::random()->type_uuid($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `uuid` is failed', [ $value ] ]);
	}


	/**
	 * @return array|\Countable
	 */
	public function assert_countable($value)
	{
		if (Lib::php()->type_countable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `countable` is failed', [ $value ] ]);
	}


	/**
	 * @return \Countable
	 */
	public function assert_countable_object($value)
	{
		if (Lib::php()->type_countable_object($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `countable_object` is failed', [ $value ] ]);
	}


	/**
	 * @return string|array|\Countable
	 */
	public function assert_sizeable($value)
	{
		if (Lib::php()->type_sizeable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `sizeable` is failed', [ $value ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone($timezone, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_timezone($timezone, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone` is failed', [ $timezone, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_offset($timezoneOrOffset)
	{
		if (Lib::date()->type_timezone_offset($timezoneOrOffset)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_offset` is failed', [ $timezoneOrOffset ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_abbr($timezoneOrAbbr)
	{
		if (Lib::date()->type_timezone_abbr($timezoneOrAbbr)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_abbr` is failed', [ $timezoneOrAbbr ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_name($timezoneOrName)
	{
		if (Lib::date()->type_timezone_name($timezoneOrName)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_name` is failed', [ $timezoneOrName ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_nameabbr($timezoneOrNameOrAbbr)
	{
		if (Lib::date()->type_timezone_nameabbr($timezoneOrNameOrAbbr)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_nameabbr` is failed', [ $timezoneOrNameOrAbbr ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date($datestring, $timezoneFallback = null)
	{
		if (Lib::date()->type_date($datestring, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date` is failed', [ $datestring, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate($datestring, $timezoneFallback = null)
	{
		if (Lib::date()->type_adate($datestring, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate` is failed', [ $datestring, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate($datestring, $timezoneFallback = null)
	{
		if (Lib::date()->type_idate($datestring, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate` is failed', [ $datestring, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_formatted($dateFormatted, $formats, $timezoneFallback = null)
	{
		if (Lib::date()->type_date_formatted($dateFormatted, $formats, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_formatted` is failed', [ $dateFormatted, $formats, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_formatted($dateFormatted, $formats, $timezoneFallback = null)
	{
		if (Lib::date()->type_adate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_formatted` is failed', [ $dateFormatted, $formats, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_formatted($dateFormatted, $formats, $timezoneFallback = null)
	{
		if (Lib::date()->type_idate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_formatted` is failed', [ $dateFormatted, $formats, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_tz($datestring, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_date_tz($datestring, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_tz` is failed', [ $datestring, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_tz($datestring, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_adate_tz($datestring, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_tz` is failed', [ $datestring, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_tz($datestring, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_idate_tz($datestring, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_tz` is failed', [ $datestring, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_date_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_tz_formatted` is failed', [ $dateFormatted, $formats, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_adate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_tz_formatted` is failed', [ $dateFormatted, $formats, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null)
	{
		if (Lib::date()->type_idate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_tz_formatted` is failed', [ $dateFormatted, $formats, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_microtime($microtime, $timezoneFallback = null)
	{
		if (Lib::date()->type_date_microtime($microtime, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_microtime` is failed', [ $microtime, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_microtime($microtime, $timezoneFallback = null)
	{
		if (Lib::date()->type_adate_microtime($microtime, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_microtime` is failed', [ $microtime, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_microtime($microtime, $timezoneFallback = null)
	{
		if (Lib::date()->type_idate_microtime($microtime, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_microtime` is failed', [ $microtime, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval($interval)
	{
		if (Lib::date()->type_interval($interval)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval` is failed', [ $interval ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_duration($duration)
	{
		if (Lib::date()->type_interval_duration($duration)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_duration` is failed', [ $duration ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_datestring($datestring)
	{
		if (Lib::date()->type_interval_datestring($datestring)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_datestring` is failed', [ $datestring ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_microtime($microtime)
	{
		if (Lib::date()->type_interval_microtime($microtime)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_microtime` is failed', [ $microtime ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_ago($date, ?\DateTimeInterface $from = null, ?bool $reverse = null)
	{
		if (Lib::date()->type_interval_ago($date, $from, $reverse)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_ago` is failed', [ $date, $from, $reverse ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T>
	 */
	public function assert_struct_exists($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_exists($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_exists` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T>
	 */
	public function assert_struct($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T>
	 */
	public function assert_struct_class($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_class($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_class` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return class-string
	 */
	public function assert_struct_interface($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_interface($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_interface` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return class-string
	 */
	public function assert_struct_trait($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_trait($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_trait` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T>
	 */
	public function assert_struct_enum($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_enum($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_enum` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T>
	 */
	public function assert_struct_fqcn($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_fqcn($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_fqcn` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_struct_namespace($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_namespace($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_namespace` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_struct_basename($value, ?int $flags = null)
	{
		if (Lib::php()->type_struct_basename($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_basename` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_resource($value, ?string $resourceType = null)
	{
		if (Lib::php()->type_resource($value, $resourceType)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `resource` is failed', [ $value, $resourceType ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_resource_opened($value, ?string $resourceType = null)
	{
		if (Lib::php()->type_resource_opened($value, $resourceType)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `resource_opened` is failed', [ $value, $resourceType ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_resource_closed($value)
	{
		if (Lib::php()->type_resource_closed($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `resource_closed` is failed', [ $value ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_any_not_resource($value)
	{
		if (Lib::php()->type_any_not_resource($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_resource` is failed', [ $value ] ]);
	}


	/**
	 * @return resource|\CurlHandle
	 */
	public function assert_curl($value)
	{
		if (Lib::php()->type_curl($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `curl` is failed', [ $value ] ]);
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 *
	 * @return T
	 */
	public function assert_enum_case($value, ?string $enumClass = null)
	{
		if (Lib::php()->type_enum_case($value, $enumClass)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `enum_case` is failed', [ $value, $enumClass ] ]);
	}


	/**
	 * > метод не всегда callable, поскольку строка 'class->method' не является callable
	 * > метод не всегда callable, поскольку массив [ 'class', 'method' ] не является callable, если метод публичный
	 * > используйте type_callable_string, если собираетесь вызывать метод
	 * > используйте type_callable_array, если собираетесь вызывать метод
	 * @param array{ 0?: array{ 0: class-string, 1: string }, 1?: string } $refs
	 *
	 * @return bool
	 */
	public function assert_method($value, array $refs = [])
	{
		if (Lib::php()->type_method($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `method` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return array{ 0: class-string, 1: string }
	 */
	public function assert_method_array($value)
	{
		if (Lib::php()->type_method_array($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `method_array` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_method_string($value)
	{
		if (Lib::php()->type_method_string($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `method_string` is failed', [ $value ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable
	 */
	public function assert_callable($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_object($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable|\Closure|object
	 */
	public function assert_callable_object($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_object($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_object` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return \Closure
	 */
	public function assert_callable_object_closure($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_object_closure($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_object_closure` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable|object
	 */
	public function assert_callable_object_invokable($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_object_invokable($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_object_invokable` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: object|class-string, 1: string }
	 */
	public function assert_callable_array($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_array($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: object|class-string, 1: string }
	 */
	public function assert_callable_array_method($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_array_method($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array_method` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: class-string, 1: string }
	 */
	public function assert_callable_array_method_static($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_array_method_static($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array_method_static` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: object, 1: string }
	 */
	public function assert_callable_array_method_non_static($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_array_method_non_static($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array_method_non_static` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable|callable-string
	 */
	public function assert_callable_string($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_string($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable|callable-string
	 */
	public function assert_callable_string_function($value)
	{
		if (Lib::php()->type_callable_string_function($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_function` is failed', [ $value ] ]);
	}


	/**
	 * @return callable|callable-string
	 */
	public function assert_callable_string_function_internal($value)
	{
		if (Lib::php()->type_callable_string_function_internal($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_function_internal` is failed', [ $value ] ]);
	}


	/**
	 * @return callable|callable-string
	 */
	public function assert_callable_string_function_non_internal($value)
	{
		if (Lib::php()->type_callable_string_function_non_internal($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_function_non_internal` is failed', [ $value ] ]);
	}


	/**
	 * @return callable|callable-string
	 */
	public function assert_callable_string_method_static($value, $newScope = 'static')
	{
		if (Lib::php()->type_callable_string_method_static($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_method_static` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_chmod($value)
	{
		if (Lib::fs()->type_chmod($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `chmod` is failed', [ $value ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_path($value, array $refs = [])
	{
		if (Lib::fs()->type_path($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `path` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_realpath($value, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (Lib::fs()->type_realpath($value, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `realpath` is failed', [ $value, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_freepath($value, array $refs = [])
	{
		if (Lib::fs()->type_freepath($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `freepath` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_dirpath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (Lib::fs()->type_dirpath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dirpath` is failed', [ $value, $isAllowExists, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_filepath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (Lib::fs()->type_filepath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `filepath` is failed', [ $value, $isAllowExists, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_dirpath_realpath($value, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (Lib::fs()->type_dirpath_realpath($value, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dirpath_realpath` is failed', [ $value, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_filepath_realpath($value, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (Lib::fs()->type_filepath_realpath($value, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `filepath_realpath` is failed', [ $value, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_filename($value)
	{
		if (Lib::fs()->type_filename($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `filename` is failed', [ $value ] ]);
	}


	/**
	 * @return \SplFileInfo
	 */
	public function assert_file($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null)
	{
		if (Lib::fs()->type_file($value, $extensions, $mimeTypes, $filters)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `file` is failed', [ $value, $extensions, $mimeTypes, $filters ] ]);
	}


	/**
	 * @return \SplFileInfo
	 */
	public function assert_image($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null)
	{
		if (Lib::fs()->type_image($value, $extensions, $mimeTypes, $filters)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `image` is failed', [ $value, $extensions, $mimeTypes, $filters ] ]);
	}


	/**
	 * @return resource|\Socket
	 */
	public function assert_socket($value)
	{
		if (Lib::fs()->type_socket($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `socket` is failed', [ $value ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_stream($value)
	{
		if (Lib::fs()->type_stream($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `stream` is failed', [ $value ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_email($value, ?array $filters = null, array $refs = [])
	{
		if (Lib::social()->type_email($value, $filters, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `email` is failed', [ $value, $filters, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_email_fake($value, array $refs = [])
	{
		if (Lib::social()->type_email_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `email_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_email_non_fake($value, ?array $filters = null, array $refs = [])
	{
		if (Lib::social()->type_email_non_fake($value, $filters, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `email_non_fake` is failed', [ $value, $filters, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone($value, array $refs = [])
	{
		if (Lib::social()->type_phone($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone_fake($value, array $refs = [])
	{
		if (Lib::social()->type_phone_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone_non_fake($value, array $refs = [])
	{
		if (Lib::social()->type_phone_non_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone_non_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string, 3?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone_real($value, ?string $region = '', array $refs = [])
	{
		if (Lib::social()->type_phone_real($value, $region, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone_real` is failed', [ $value, $region, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel($value, array $refs = [])
	{
		if (Lib::social()->type_tel($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel_fake($value, array $refs = [])
	{
		if (Lib::social()->type_tel_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel_non_fake($value, array $refs = [])
	{
		if (Lib::social()->type_tel_non_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel_non_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel_real($value, ?string $region = '', array $refs = [])
	{
		if (Lib::social()->type_tel_real($value, $region, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel_real` is failed', [ $value, $region, $refs ] ]);
	}
}
