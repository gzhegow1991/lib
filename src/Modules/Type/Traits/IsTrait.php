<?php

/**
 * This class is autogenerated.
 */

namespace Gzhegow\Lib\Modules\Type\Traits;

use Gzhegow\Lib\Lib;

trait IsTrait
{
	public function is_empty($value): bool
	{
		return Lib::php()->type_empty($value)->isOk();
	}


	public function is_any_not_empty($value): bool
	{
		return Lib::php()->type_any_not_empty($value)->isOk();
	}


	/**
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 */
	public function is_blank($value): bool
	{
		return Lib::php()->type_blank($value)->isOk();
	}


	public function is_any_not_blank($value): bool
	{
		return Lib::php()->type_any_not_blank($value)->isOk();
	}


	/**
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 */
	public function is_nullable($value): bool
	{
		return Lib::php()->type_nullable($value)->isOk();
	}


	public function is_any_not_nullable($value): bool
	{
		return Lib::php()->type_any_not_nullable($value)->isOk();
	}


	/**
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 */
	public function is_passed($value): bool
	{
		return Lib::php()->type_passed($value)->isOk();
	}


	public function is_any_not_passed($value): bool
	{
		return Lib::php()->type_any_not_passed($value)->isOk();
	}


	/**
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 */
	public function is_nil($value): bool
	{
		return Lib::php()->type_nil($value)->isOk();
	}


	public function is_any_not_nil($value): bool
	{
		return Lib::php()->type_any_not_nil($value)->isOk();
	}


	public function is_null($value): bool
	{
		return Lib::php()->type_null($value)->isOk();
	}


	public function is_any_not_null($value): bool
	{
		return Lib::php()->type_any_not_null($value)->isOk();
	}


	public function is_false($value): bool
	{
		return Lib::php()->type_false($value)->isOk();
	}


	public function is_any_not_false($value): bool
	{
		return Lib::php()->type_any_not_false($value)->isOk();
	}


	public function is_true($value): bool
	{
		return Lib::php()->type_true($value)->isOk();
	}


	public function is_any_not_true($value): bool
	{
		return Lib::php()->type_any_not_true($value)->isOk();
	}


	public function is_bool($value): bool
	{
		return Lib::php()->type_bool($value)->isOk();
	}


	public function is_boolfalse($value): bool
	{
		return Lib::php()->type_boolfalse($value)->isOk();
	}


	public function is_booltrue($value): bool
	{
		return Lib::php()->type_booltrue($value)->isOk();
	}


	public function is_userbool($value): bool
	{
		return Lib::php()->type_userbool($value)->isOk();
	}


	public function is_userfalse($value): bool
	{
		return Lib::php()->type_userfalse($value)->isOk();
	}


	public function is_usertrue($value): bool
	{
		return Lib::php()->type_usertrue($value)->isOk();
	}


	public function is_array($value): bool
	{
		return Lib::php()->type_array($value)->isOk();
	}


	public function is_array_empty($value): bool
	{
		return Lib::php()->type_array_empty($value)->isOk();
	}


	public function is_array_not_empty($value): bool
	{
		return Lib::php()->type_array_not_empty($value)->isOk();
	}


	public function is_any_not_array_empty($value): bool
	{
		return Lib::php()->type_any_not_array_empty($value)->isOk();
	}


	public function is_any_not_array($value): bool
	{
		return Lib::php()->type_any_not_array($value)->isOk();
	}


	public function is_object($value): bool
	{
		return Lib::php()->type_object($value)->isOk();
	}


	public function is_any_not_object($value): bool
	{
		return Lib::php()->type_any_not_object($value)->isOk();
	}


	public function is_stdclass($value): bool
	{
		return Lib::php()->type_stdclass($value)->isOk();
	}


	public function is_any_not_stdclass($value): bool
	{
		return Lib::php()->type_any_not_stdclass($value)->isOk();
	}


	public function is_nan($value): bool
	{
		return Lib::num()->type_nan($value)->isOk();
	}


	public function is_float_not_nan($value): bool
	{
		return Lib::num()->type_float_not_nan($value)->isOk();
	}


	public function is_any_not_nan($value): bool
	{
		return Lib::num()->type_any_not_nan($value)->isOk();
	}


	public function is_finite($value): bool
	{
		return Lib::num()->type_finite($value)->isOk();
	}


	public function is_float_not_finite($value): bool
	{
		return Lib::num()->type_float_not_finite($value)->isOk();
	}


	public function is_any_not_finite($value): bool
	{
		return Lib::num()->type_any_not_finite($value)->isOk();
	}


	public function is_infinite($value): bool
	{
		return Lib::num()->type_infinite($value)->isOk();
	}


	public function is_float_not_infinite($value): bool
	{
		return Lib::num()->type_float_not_infinite($value)->isOk();
	}


	public function is_any_not_infinite($value): bool
	{
		return Lib::num()->type_any_not_infinite($value)->isOk();
	}


	public function is_float_min($value): bool
	{
		return Lib::num()->type_float_min($value)->isOk();
	}


	public function is_float_not_float_min($value): bool
	{
		return Lib::num()->type_float_not_float_min($value)->isOk();
	}


	public function is_any_not_float_min($value): bool
	{
		return Lib::num()->type_any_not_float_min($value)->isOk();
	}


	public function is_number($value, ?bool $isAllowExp = null): bool
	{
		return Lib::num()->type_number($value, $isAllowExp)->isOk();
	}


	public function is_numeric($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return Lib::num()->type_numeric($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_non_zero($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return Lib::num()->type_numeric_non_zero($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_non_negative($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return Lib::num()->type_numeric_non_negative($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_non_positive($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return Lib::num()->type_numeric_non_positive($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_negative($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return Lib::num()->type_numeric_negative($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_positive($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return Lib::num()->type_numeric_positive($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_int($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int($value, $refs)->isOk();
	}


	public function is_numeric_int_non_zero($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_non_zero($value, $refs)->isOk();
	}


	public function is_numeric_int_non_negative($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_non_negative($value, $refs)->isOk();
	}


	public function is_numeric_int_non_positive($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_non_positive($value, $refs)->isOk();
	}


	public function is_numeric_int_negative($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_negative($value, $refs)->isOk();
	}


	public function is_numeric_int_positive($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_positive($value, $refs)->isOk();
	}


	public function is_numeric_int_positive_or_minus_one($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_positive_or_minus_one($value, $refs)->isOk();
	}


	public function is_numeric_int_non_negative_or_minus_one($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_int_non_negative_or_minus_one($value, $refs)->isOk();
	}


	public function is_numeric_float($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_float($value, $refs)->isOk();
	}


	public function is_numeric_float_non_zero($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_float_non_zero($value, $refs)->isOk();
	}


	public function is_numeric_float_non_negative($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_float_non_negative($value, $refs)->isOk();
	}


	public function is_numeric_float_non_positive($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_float_non_positive($value, $refs)->isOk();
	}


	public function is_numeric_float_negative($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_float_negative($value, $refs)->isOk();
	}


	public function is_numeric_float_positive($value, array $refs = []): bool
	{
		return Lib::num()->type_numeric_float_positive($value, $refs)->isOk();
	}


	public function is_numeric_trimpad(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return Lib::num()->type_numeric_trimpad($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_non_zero(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return Lib::num()->type_numeric_trimpad_non_zero($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_non_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return Lib::num()->type_numeric_trimpad_non_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_non_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return Lib::num()->type_numeric_trimpad_non_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return Lib::num()->type_numeric_trimpad_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return Lib::num()->type_numeric_trimpad_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_decimal($value, int $scale = 0, array $refs = []): bool
	{
		return Lib::num()->type_decimal($value, $scale, $refs)->isOk();
	}


	public function is_decimal_non_zero($value, int $scale = 0, array $refs = []): bool
	{
		return Lib::num()->type_decimal_non_zero($value, $scale, $refs)->isOk();
	}


	public function is_decimal_non_negative($value, int $scale = 0, array $refs = []): bool
	{
		return Lib::num()->type_decimal_non_negative($value, $scale, $refs)->isOk();
	}


	public function is_decimal_non_positive($value, int $scale = 0, array $refs = []): bool
	{
		return Lib::num()->type_decimal_non_positive($value, $scale, $refs)->isOk();
	}


	public function is_decimal_negative($value, int $scale = 0, array $refs = []): bool
	{
		return Lib::num()->type_decimal_negative($value, $scale, $refs)->isOk();
	}


	public function is_decimal_positive($value, int $scale = 0, array $refs = []): bool
	{
		return Lib::num()->type_decimal_positive($value, $scale, $refs)->isOk();
	}


	public function is_num($value): bool
	{
		return Lib::num()->type_num($value)->isOk();
	}


	public function is_num_non_zero($value): bool
	{
		return Lib::num()->type_num_non_zero($value)->isOk();
	}


	public function is_num_non_negative($value): bool
	{
		return Lib::num()->type_num_non_negative($value)->isOk();
	}


	public function is_num_non_positive($value): bool
	{
		return Lib::num()->type_num_non_positive($value)->isOk();
	}


	public function is_num_negative($value): bool
	{
		return Lib::num()->type_num_negative($value)->isOk();
	}


	public function is_num_positive($value): bool
	{
		return Lib::num()->type_num_positive($value)->isOk();
	}


	public function is_int($value): bool
	{
		return Lib::num()->type_int($value)->isOk();
	}


	public function is_int_non_zero($value): bool
	{
		return Lib::num()->type_int_non_zero($value)->isOk();
	}


	public function is_int_non_negative($value): bool
	{
		return Lib::num()->type_int_non_negative($value)->isOk();
	}


	public function is_int_non_positive($value): bool
	{
		return Lib::num()->type_int_non_positive($value)->isOk();
	}


	public function is_int_negative($value): bool
	{
		return Lib::num()->type_int_negative($value)->isOk();
	}


	public function is_int_positive($value): bool
	{
		return Lib::num()->type_int_positive($value)->isOk();
	}


	public function is_int_positive_or_minus_one($value): bool
	{
		return Lib::num()->type_int_positive_or_minus_one($value)->isOk();
	}


	public function is_int_non_negative_or_minus_one($value): bool
	{
		return Lib::num()->type_int_non_negative_or_minus_one($value)->isOk();
	}


	public function is_float($value): bool
	{
		return Lib::num()->type_float($value)->isOk();
	}


	public function is_float_non_zero($value): bool
	{
		return Lib::num()->type_float_non_zero($value)->isOk();
	}


	public function is_float_non_negative($value): bool
	{
		return Lib::num()->type_float_non_negative($value)->isOk();
	}


	public function is_float_non_positive($value): bool
	{
		return Lib::num()->type_float_non_positive($value)->isOk();
	}


	public function is_float_negative($value): bool
	{
		return Lib::num()->type_float_negative($value)->isOk();
	}


	public function is_float_positive($value): bool
	{
		return Lib::num()->type_float_positive($value)->isOk();
	}


	public function is_bcnumber($value): bool
	{
		return Lib::bcmath()->type_bcnumber($value)->isOk();
	}


	public function is_a_string($value): bool
	{
		return Lib::str()->type_a_string($value)->isOk();
	}


	public function is_a_string_empty($value): bool
	{
		return Lib::str()->type_a_string_empty($value)->isOk();
	}


	public function is_a_string_not_empty($value): bool
	{
		return Lib::str()->type_a_string_not_empty($value)->isOk();
	}


	public function is_a_trim($value): bool
	{
		return Lib::str()->type_a_trim($value)->isOk();
	}


	public function is_string($value): bool
	{
		return Lib::str()->type_string($value)->isOk();
	}


	public function is_string_empty($value): bool
	{
		return Lib::str()->type_string_empty($value)->isOk();
	}


	public function is_string_not_empty($value): bool
	{
		return Lib::str()->type_string_not_empty($value)->isOk();
	}


	public function is_trim($value, ?string $characters = null): bool
	{
		return Lib::str()->type_trim($value, $characters)->isOk();
	}


	public function is_char($value): bool
	{
		return Lib::str()->type_char($value)->isOk();
	}


	public function is_letter($value): bool
	{
		return Lib::str()->type_letter($value)->isOk();
	}


	public function is_word($value): bool
	{
		return Lib::str()->type_word($value)->isOk();
	}


	public function is_alphabet($value): bool
	{
		return Lib::str()->type_alphabet($value)->isOk();
	}


	public function is_ctype_digit($value): bool
	{
		return Lib::str()->type_ctype_digit($value)->isOk();
	}


	public function is_ctype_alpha($value, ?bool $allowUpperCase = null): bool
	{
		return Lib::str()->type_ctype_alpha($value, $allowUpperCase)->isOk();
	}


	public function is_ctype_alnum($value, ?bool $allowUpperCase = null): bool
	{
		return Lib::str()->type_ctype_alnum($value, $allowUpperCase)->isOk();
	}


	public function is_base($value, $alphabet): bool
	{
		return Lib::crypt()->type_base($value, $alphabet)->isOk();
	}


	public function is_base_bin($value): bool
	{
		return Lib::crypt()->type_base_bin($value)->isOk();
	}


	public function is_base_oct($value): bool
	{
		return Lib::crypt()->type_base_oct($value)->isOk();
	}


	public function is_base_dec($value): bool
	{
		return Lib::crypt()->type_base_dec($value)->isOk();
	}


	public function is_base_hex($value): bool
	{
		return Lib::crypt()->type_base_hex($value)->isOk();
	}


	public function is_key($key): bool
	{
		return Lib::arr()->type_key($key)->isOk();
	}


	public function is_key_exists($key, array $array): bool
	{
		return Lib::arr()->type_key_exists($key, $array)->isOk();
	}


	public function is_key_not_exists($key, array $array): bool
	{
		return Lib::arr()->type_key_not_exists($key, $array)->isOk();
	}


	public function is_array_plain($value, ?int $maxDepth = null): bool
	{
		return Lib::arr()->type_array_plain($value, $maxDepth)->isOk();
	}


	public function is_list($value, ?int $plainMaxDepth = null): bool
	{
		return Lib::arr()->type_list($value, $plainMaxDepth)->isOk();
	}


	public function is_list_sorted($value, ?int $plainMaxDepth = null): bool
	{
		return Lib::arr()->type_list_sorted($value, $plainMaxDepth)->isOk();
	}


	public function is_dict($value, ?int $plainMaxDepth = null): bool
	{
		return Lib::arr()->type_dict($value, $plainMaxDepth)->isOk();
	}


	public function is_dict_sorted($value, ?int $plainMaxDepth = null, $fnSortCmp = null): bool
	{
		return Lib::arr()->type_dict_sorted($value, $plainMaxDepth, $fnSortCmp)->isOk();
	}


	public function is_table($value): bool
	{
		return Lib::arr()->type_table($value)->isOk();
	}


	public function is_matrix($value): bool
	{
		return Lib::arr()->type_matrix($value)->isOk();
	}


	public function is_matrix_strict($value): bool
	{
		return Lib::arr()->type_matrix_strict($value)->isOk();
	}


	public function is_arrpath($path): bool
	{
		return Lib::arr()->type_arrpath($path)->isOk();
	}


	public function is_arrpath_dot($path, ?string $dot = '.'): bool
	{
		return Lib::arr()->type_arrpath_dot($path, $dot)->isOk();
	}


	public function is_array_of_type($value, string $type): bool
	{
		return Lib::arr()->type_array_of_type($value, $type)->isOk();
	}


	public function is_array_of_resource_type($value, string $resourceType): bool
	{
		return Lib::arr()->type_array_of_resource_type($value, $resourceType)->isOk();
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 */
	public function is_array_of_a($value, string $className): bool
	{
		return Lib::arr()->type_array_of_a($value, $className)->isOk();
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 */
	public function is_array_of_class($value, string $className): bool
	{
		return Lib::arr()->type_array_of_class($value, $className)->isOk();
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 */
	public function is_array_of_subclass($value, string $className): bool
	{
		return Lib::arr()->type_array_of_subclass($value, $className)->isOk();
	}


	/**
	 * @param callable $fn
	 *
	 * @noinspection PhpDocSignatureIsNotCompleteInspection
	 */
	public function is_array_of_callback($value, callable $fn, array $args = []): bool
	{
		return Lib::arr()->type_array_of_callback($value, $fn, $args)->isOk();
	}


	public function is_fileline($value): bool
	{
		return Lib::debug()->type_fileline($value)->isOk();
	}


	public function is_html_tag($value): bool
	{
		return Lib::format()->type_html_tag($value)->isOk();
	}


	public function is_xml_tag($value): bool
	{
		return Lib::format()->type_xml_tag($value)->isOk();
	}


	public function is_xml_nstag($value): bool
	{
		return Lib::format()->type_xml_nstag($value)->isOk();
	}


	public function is_regex($value): bool
	{
		return Lib::preg()->type_regex($value)->isOk();
	}


	public function is_regexp($value): bool
	{
		return Lib::preg()->type_regexp($value)->isOk();
	}


	public function is_address_ip($value): bool
	{
		return Lib::net()->type_address_ip($value)->isOk();
	}


	public function is_address_ip_v4($value): bool
	{
		return Lib::net()->type_address_ip_v4($value)->isOk();
	}


	public function is_address_ip_v6($value): bool
	{
		return Lib::net()->type_address_ip_v6($value)->isOk();
	}


	public function is_address_mac($value): bool
	{
		return Lib::net()->type_address_mac($value)->isOk();
	}


	public function is_subnet($value, ?string $ipFallback = null): bool
	{
		return Lib::net()->type_subnet($value, $ipFallback)->isOk();
	}


	public function is_subnet_v4($value, ?string $ipFallback = null): bool
	{
		return Lib::net()->type_subnet_v4($value, $ipFallback)->isOk();
	}


	public function is_subnet_v6($value, ?string $ipFallback = null): bool
	{
		return Lib::net()->type_subnet_v6($value, $ipFallback)->isOk();
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function is_url(
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		return Lib::url()->type_url($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs)->isOk();
	}


	/**
	 * @param string|true $value
	 */
	public function is_host($value, ?int $isHostIdnaAscii = null, array $refs = []): bool
	{
		return Lib::url()->type_host($value, $isHostIdnaAscii, $refs)->isOk();
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function is_link($value, $query = null, $fragment = null, ?int $isLinkUrlencoded = null, array $refs = []): bool
	{
		return Lib::url()->type_link($value, $query, $fragment, $isLinkUrlencoded, $refs)->isOk();
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function is_uri(
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		return Lib::url()->type_uri($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs)->isOk();
	}


	/**
	 * @param string $value
	 */
	public function is_dsn_pdo($value, array $refs = []): bool
	{
		return Lib::url()->type_dsn_pdo($value, $refs)->isOk();
	}


	public function is_uuid($value): bool
	{
		return Lib::random()->type_uuid($value)->isOk();
	}


	public function is_countable($value): bool
	{
		return Lib::php()->type_countable($value)->isOk();
	}


	public function is_countable_object($value): bool
	{
		return Lib::php()->type_countable_object($value)->isOk();
	}


	public function is_sizeable($value): bool
	{
		return Lib::php()->type_sizeable($value)->isOk();
	}


	public function is_timezone($timezone, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_timezone($timezone, $allowedTimezoneTypes)->isOk();
	}


	public function is_timezone_offset($timezoneOrOffset): bool
	{
		return Lib::date()->type_timezone_offset($timezoneOrOffset)->isOk();
	}


	public function is_timezone_abbr($timezoneOrAbbr): bool
	{
		return Lib::date()->type_timezone_abbr($timezoneOrAbbr)->isOk();
	}


	public function is_timezone_name($timezoneOrName): bool
	{
		return Lib::date()->type_timezone_name($timezoneOrName)->isOk();
	}


	public function is_timezone_nameabbr($timezoneOrNameOrAbbr): bool
	{
		return Lib::date()->type_timezone_nameabbr($timezoneOrNameOrAbbr)->isOk();
	}


	public function is_date($datestring, $timezoneFallback = null): bool
	{
		return Lib::date()->type_date($datestring, $timezoneFallback)->isOk();
	}


	public function is_adate($datestring, $timezoneFallback = null): bool
	{
		return Lib::date()->type_adate($datestring, $timezoneFallback)->isOk();
	}


	public function is_idate($datestring, $timezoneFallback = null): bool
	{
		return Lib::date()->type_idate($datestring, $timezoneFallback)->isOk();
	}


	public function is_date_formatted($dateFormatted, $formats, $timezoneFallback = null): bool
	{
		return Lib::date()->type_date_formatted($dateFormatted, $formats, $timezoneFallback)->isOk();
	}


	public function is_adate_formatted($dateFormatted, $formats, $timezoneFallback = null): bool
	{
		return Lib::date()->type_adate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk();
	}


	public function is_idate_formatted($dateFormatted, $formats, $timezoneFallback = null): bool
	{
		return Lib::date()->type_idate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk();
	}


	public function is_date_tz($datestring, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_date_tz($datestring, $allowedTimezoneTypes)->isOk();
	}


	public function is_adate_tz($datestring, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_adate_tz($datestring, $allowedTimezoneTypes)->isOk();
	}


	public function is_idate_tz($datestring, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_idate_tz($datestring, $allowedTimezoneTypes)->isOk();
	}


	public function is_date_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_date_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk();
	}


	public function is_adate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_adate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk();
	}


	public function is_idate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		return Lib::date()->type_idate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk();
	}


	public function is_date_microtime($microtime, $timezoneFallback = null): bool
	{
		return Lib::date()->type_date_microtime($microtime, $timezoneFallback)->isOk();
	}


	public function is_adate_microtime($microtime, $timezoneFallback = null): bool
	{
		return Lib::date()->type_adate_microtime($microtime, $timezoneFallback)->isOk();
	}


	public function is_idate_microtime($microtime, $timezoneFallback = null): bool
	{
		return Lib::date()->type_idate_microtime($microtime, $timezoneFallback)->isOk();
	}


	public function is_interval($interval): bool
	{
		return Lib::date()->type_interval($interval)->isOk();
	}


	public function is_interval_duration($duration): bool
	{
		return Lib::date()->type_interval_duration($duration)->isOk();
	}


	public function is_interval_datestring($datestring): bool
	{
		return Lib::date()->type_interval_datestring($datestring)->isOk();
	}


	public function is_interval_microtime($microtime): bool
	{
		return Lib::date()->type_interval_microtime($microtime)->isOk();
	}


	public function is_interval_ago($date, ?\DateTimeInterface $from = null, ?bool $reverse = null): bool
	{
		return Lib::date()->type_interval_ago($date, $from, $reverse)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_exists($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_exists($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_class($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_class($value, $flags)->isOk();
	}


	public function is_struct_interface($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_interface($value, $flags)->isOk();
	}


	public function is_struct_trait($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_trait($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_enum($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_enum($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_fqcn($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_fqcn($value, $flags)->isOk();
	}


	public function is_struct_namespace($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_namespace($value, $flags)->isOk();
	}


	public function is_struct_basename($value, ?int $flags = null): bool
	{
		return Lib::php()->type_struct_basename($value, $flags)->isOk();
	}


	public function is_resource($value, ?string $resourceType = null): bool
	{
		return Lib::php()->type_resource($value, $resourceType)->isOk();
	}


	public function is_resource_opened($value, ?string $resourceType = null): bool
	{
		return Lib::php()->type_resource_opened($value, $resourceType)->isOk();
	}


	public function is_resource_closed($value): bool
	{
		return Lib::php()->type_resource_closed($value)->isOk();
	}


	public function is_any_not_resource($value): bool
	{
		return Lib::php()->type_any_not_resource($value)->isOk();
	}


	public function is_curl($value): bool
	{
		return Lib::php()->type_curl($value)->isOk();
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 */
	public function is_enum_case($value, ?string $enumClass = null): bool
	{
		return Lib::php()->type_enum_case($value, $enumClass)->isOk();
	}


	/**
	 * > метод не всегда callable, поскольку строка 'class->method' не является callable
	 * > метод не всегда callable, поскольку массив [ 'class', 'method' ] не является callable, если метод публичный
	 * > используйте type_callable_string, если собираетесь вызывать метод
	 * > используйте type_callable_array, если собираетесь вызывать метод
	 * @param array{ 0?: array{ 0: class-string, 1: string }, 1?: string } $refs
	 */
	public function is_method($value, array $refs = []): bool
	{
		return Lib::php()->type_method($value, $refs)->isOk();
	}


	public function is_method_array($value): bool
	{
		return Lib::php()->type_method_array($value)->isOk();
	}


	public function is_method_string($value): bool
	{
		return Lib::php()->type_method_string($value)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_object($value, $newScope)->isOk();
	}


	public function is_callable_object($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_object($value, $newScope)->isOk();
	}


	public function is_callable_object_closure($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_object_closure($value, $newScope)->isOk();
	}


	public function is_callable_object_invokable($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_object_invokable($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_array($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array_method($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_array_method($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array_method_static($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_array_method_static($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array_method_non_static($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_array_method_non_static($value, $newScope)->isOk();
	}


	public function is_callable_string($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_string($value, $newScope)->isOk();
	}


	public function is_callable_string_function($value): bool
	{
		return Lib::php()->type_callable_string_function($value)->isOk();
	}


	public function is_callable_string_function_internal($value): bool
	{
		return Lib::php()->type_callable_string_function_internal($value)->isOk();
	}


	public function is_callable_string_function_non_internal($value): bool
	{
		return Lib::php()->type_callable_string_function_non_internal($value)->isOk();
	}


	public function is_callable_string_method_static($value, $newScope = 'static'): bool
	{
		return Lib::php()->type_callable_string_method_static($value, $newScope)->isOk();
	}


	public function is_chmod($value): bool
	{
		return Lib::fs()->type_chmod($value)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_path($value, array $refs = []): bool
	{
		return Lib::fs()->type_path($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_realpath($value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return Lib::fs()->type_realpath($value, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_freepath($value, array $refs = []): bool
	{
		return Lib::fs()->type_freepath($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_dirpath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return Lib::fs()->type_dirpath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_filepath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return Lib::fs()->type_filepath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_dirpath_realpath($value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return Lib::fs()->type_dirpath_realpath($value, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_filepath_realpath($value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return Lib::fs()->type_filepath_realpath($value, $isAllowSymlink, $refs)->isOk();
	}


	public function is_filename($value): bool
	{
		return Lib::fs()->type_filename($value)->isOk();
	}


	public function is_file($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null): bool
	{
		return Lib::fs()->type_file($value, $extensions, $mimeTypes, $filters)->isOk();
	}


	public function is_image($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null): bool
	{
		return Lib::fs()->type_image($value, $extensions, $mimeTypes, $filters)->isOk();
	}


	public function is_socket($value): bool
	{
		return Lib::fs()->type_socket($value)->isOk();
	}


	public function is_stream($value): bool
	{
		return Lib::fs()->type_stream($value)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_email($value, ?array $filters = null, array $refs = []): bool
	{
		return Lib::social()->type_email($value, $filters, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_email_fake($value, array $refs = []): bool
	{
		return Lib::social()->type_email_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_email_non_fake($value, ?array $filters = null, array $refs = []): bool
	{
		return Lib::social()->type_email_non_fake($value, $filters, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_phone($value, array $refs = []): bool
	{
		return Lib::social()->type_phone($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_phone_fake($value, array $refs = []): bool
	{
		return Lib::social()->type_phone_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_phone_non_fake($value, array $refs = []): bool
	{
		return Lib::social()->type_phone_non_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string, 3?: string } $refs
	 */
	public function is_phone_real($value, ?string $region = '', array $refs = []): bool
	{
		return Lib::social()->type_phone_real($value, $region, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_tel($value, array $refs = []): bool
	{
		return Lib::social()->type_tel($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_tel_fake($value, array $refs = []): bool
	{
		return Lib::social()->type_tel_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_tel_non_fake($value, array $refs = []): bool
	{
		return Lib::social()->type_tel_non_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_tel_real($value, ?string $region = '', array $refs = []): bool
	{
		return Lib::social()->type_tel_real($value, $region, $refs)->isOk();
	}
}
