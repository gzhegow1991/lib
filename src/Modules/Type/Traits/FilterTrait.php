<?php

/**
 * This class is autogenerated.
 */

namespace Gzhegow\Lib\Modules\Type\Traits;

use Gzhegow\Lib\Lib;
use Gzhegow\Lib\Modules\Arr\ArrPath;
use Gzhegow\Lib\Modules\Bcmath\Bcnumber;
use Gzhegow\Lib\Modules\Bcmath\Number;
use Gzhegow\Lib\Modules\Net\AddressIpV4;
use Gzhegow\Lib\Modules\Net\AddressIpV6;
use Gzhegow\Lib\Modules\Net\SubnetV4;
use Gzhegow\Lib\Modules\Net\SubnetV6;
use Gzhegow\Lib\Modules\Php\Nil;
use Gzhegow\Lib\Modules\Str\Alphabet;
use Gzhegow\Lib\Modules\Type\Ret;

trait FilterTrait
{
	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string|array|\Countable|null, 1?: Ret<string|array|\Countable|null> } $r
	 *
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 */
	public function filter_blank(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_blank($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_blank(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_blank($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 *
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 */
	public function filter_nullable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_nullable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_nullable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_nullable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 *
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 */
	public function filter_passed(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_passed($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_passed(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_passed($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string|Nil, 1?: Ret<string|Nil> } $r
	 *
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 */
	public function filter_nil(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_nil($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_nil(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_nil($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: null, 1?: Ret<null> } $r
	 */
	public function filter_null(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_null($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_null(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_null($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_false(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_false($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_false(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_false($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: true, 1?: Ret<true> } $r
	 */
	public function filter_true(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_true($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_true(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_true($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: bool, 1?: Ret<bool> } $r
	 */
	public function filter_bool(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_bool($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_boolfalse(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_boolfalse($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: true, 1?: Ret<true> } $r
	 */
	public function filter_booltrue(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_booltrue($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: bool, 1?: Ret<bool> } $r
	 */
	public function filter_userbool(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_userbool($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_userfalse(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_userfalse($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_usertrue(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_usertrue($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_array($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_array_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_array_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_array_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_array_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_array(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_array($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: object, 1?: Ret<object> } $r
	 */
	public function filter_object(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_object($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_object(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_object($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \stdClass, 1?: Ret<\stdClass> } $r
	 */
	public function filter_stdclass(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_stdclass($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_stdclass(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_stdclass($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_nan(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_nan($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_nan(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_not_nan($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_nan(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_any_not_nan($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_finite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_finite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_finite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_not_finite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_finite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_any_not_finite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_infinite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_infinite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_infinite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_not_infinite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_infinite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_any_not_infinite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_min(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_min($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_float_min(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_not_float_min($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_float_min(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_any_not_float_min($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: Number, 1?: Ret<Number> } $r
	 */
	public function filter_number(array $r, $value, ?bool $isAllowExp = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_number($value, $isAllowExp))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_non_zero(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_non_zero($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_non_negative(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_non_negative($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_non_positive(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_non_positive($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_negative(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_negative($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_positive(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_positive($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_zero(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_non_zero($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_non_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_non_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_positive_or_minus_one(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_positive_or_minus_one($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_negative_or_minus_one(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_int_non_negative_or_minus_one($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_float($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_non_zero(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_float_non_zero($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_non_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_float_non_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_non_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_float_non_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_float_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_float_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_trimpad($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_non_zero(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_trimpad_non_zero($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_non_negative(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_trimpad_non_negative($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_non_positive(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_trimpad_non_positive($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_negative(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_trimpad_negative($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_positive(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_numeric_trimpad_positive($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_decimal($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_non_zero(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_decimal_non_zero($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_non_negative(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_decimal_non_negative($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_non_positive(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_decimal_non_positive($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_negative(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_decimal_negative($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_positive(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_decimal_positive($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_num($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_non_zero(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_num_non_zero($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_non_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_num_non_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_non_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_num_non_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_num_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_num_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_zero(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_non_zero($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_non_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_non_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_positive_or_minus_one(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_positive_or_minus_one($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_negative_or_minus_one(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_int_non_negative_or_minus_one($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_non_zero(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_non_zero($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_non_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_non_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_non_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_non_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::num()->type_float_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: Bcnumber, 1?: Ret<Bcnumber> } $r
	 */
	public function filter_bcnumber(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::bcmath()->type_bcnumber($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_string(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_a_string($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_string_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_a_string_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_string_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_a_string_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_trim(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_a_trim($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_string(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_string($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_string_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_string_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_string_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_string_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_trim(array $r, $value, ?string $characters = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_trim($value, $characters))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_char(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_char($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_letter(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_letter($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_word(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_word($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: Alphabet, 1?: Ret<Alphabet> } $r
	 */
	public function filter_alphabet(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_alphabet($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_ctype_digit(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_ctype_digit($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_ctype_alpha(array $r, $value, ?bool $allowUpperCase = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_ctype_alpha($value, $allowUpperCase))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_ctype_alnum(array $r, $value, ?bool $allowUpperCase = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::str()->type_ctype_alnum($value, $allowUpperCase))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base(array $r, $value, $alphabet): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::crypt()->type_base($value, $alphabet))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_bin(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::crypt()->type_base_bin($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_oct(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::crypt()->type_base_oct($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_dec(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::crypt()->type_base_dec($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_hex(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::crypt()->type_base_hex($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|string, 1?: Ret<int|string> } $r
	 */
	public function filter_key(array $r, $key): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_key($key))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_key_exists(array $r, $key, array $array): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_key_exists($key, $array))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: null, 1?: Ret<null> } $r
	 */
	public function filter_key_not_exists(array $r, $key, array $array): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_key_not_exists($key, $array))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_plain(array $r, $value, ?int $maxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_plain($value, $maxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_list(array $r, $value, ?int $plainMaxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_list($value, $plainMaxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_list_sorted(array $r, $value, ?int $plainMaxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_list_sorted($value, $plainMaxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_dict(array $r, $value, ?int $plainMaxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_dict($value, $plainMaxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_dict_sorted(array $r, $value, ?int $plainMaxDepth = null, $fnSortCmp = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_dict_sorted($value, $plainMaxDepth, $fnSortCmp))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_table(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_table($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_matrix(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_matrix($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_matrix_strict(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_matrix_strict($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: ArrPath, 1?: Ret<ArrPath> } $r
	 */
	public function filter_arrpath(array $r, $path): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_arrpath($path))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: ArrPath, 1?: Ret<ArrPath> } $r
	 */
	public function filter_arrpath_dot(array $r, $path, ?string $dot = '.'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_arrpath_dot($path, $dot))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_of_type(array $r, $value, string $type): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_of_type($value, $type))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource[], 1?: Ret<resource[]> } $r
	 */
	public function filter_array_of_resource_type(array $r, $value, string $resourceType): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_of_resource_type($value, $resourceType))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T[], 1?: Ret<T[]> } $r
	 *
	 * @template T
	 * @param class-string<T> $className
	 */
	public function filter_array_of_a(array $r, $value, string $className): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_of_a($value, $className))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T[], 1?: Ret<T[]> } $r
	 *
	 * @template T
	 * @param class-string<T> $className
	 */
	public function filter_array_of_class(array $r, $value, string $className): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_of_class($value, $className))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T[], 1?: Ret<T[]> } $r
	 *
	 * @template T
	 * @param class-string<T> $className
	 */
	public function filter_array_of_subclass(array $r, $value, string $className): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_of_subclass($value, $className))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 *
	 * @param callable $fn
	 *
	 * @noinspection PhpDocSignatureIsNotCompleteInspection
	 */
	public function filter_array_of_callback(array $r, $value, callable $fn, array $args = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::arr()->type_array_of_callback($value, $fn, $args))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array{ 0: string, 1: int }, 1?: Ret<array{ 0: string, 1: int }> } $r
	 */
	public function filter_fileline(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::debug()->type_fileline($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_html_tag(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::format()->type_html_tag($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_xml_tag(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::format()->type_xml_tag($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_xml_nstag(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::format()->type_xml_nstag($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_regex(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::preg()->type_regex($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_regexp(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::preg()->type_regexp($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: AddressIpV4|AddressIpV6, 1?: Ret<AddressIpV4|AddressIpV6> } $r
	 */
	public function filter_address_ip(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_address_ip($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: AddressIpV4, 1?: Ret<AddressIpV4> } $r
	 */
	public function filter_address_ip_v4(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_address_ip_v4($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: AddressIpV6, 1?: Ret<AddressIpV6> } $r
	 */
	public function filter_address_ip_v6(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_address_ip_v6($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_address_mac(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_address_mac($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: SubnetV4|SubnetV6, 1?: Ret<SubnetV4|SubnetV6> } $r
	 */
	public function filter_subnet(array $r, $value, ?string $ipFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_subnet($value, $ipFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: SubnetV4, 1?: Ret<SubnetV4> } $r
	 */
	public function filter_subnet_v4(array $r, $value, ?string $ipFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_subnet_v4($value, $ipFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: SubnetV6, 1?: Ret<SubnetV6> } $r
	 */
	public function filter_subnet_v6(array $r, $value, ?string $ipFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::net()->type_subnet_v6($value, $ipFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function filter_url(
		array $r,
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::url()->type_url($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string|true $value
	 */
	public function filter_host(array $r, $value, ?int $isHostIdnaAscii = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::url()->type_host($value, $isHostIdnaAscii, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function filter_link(
		array $r,
		$value,
		$query = null,
		$fragment = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::url()->type_link($value, $query, $fragment, $isLinkUrlencoded, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string $value
	 */
	public function filter_dsn_pdo(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::url()->type_dsn_pdo($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_uuid(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::random()->type_uuid($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array|\Countable, 1?: Ret<array|\Countable> } $r
	 */
	public function filter_countable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_countable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \Countable, 1?: Ret<\Countable> } $r
	 */
	public function filter_countable_object(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_countable_object($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string|array|\Countable, 1?: Ret<string|array|\Countable> } $r
	 */
	public function filter_sizeable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_sizeable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone(array $r, $timezone, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_timezone($timezone, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_offset(array $r, $timezoneOrOffset): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_timezone_offset($timezoneOrOffset))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_abbr(array $r, $timezoneOrAbbr): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_timezone_abbr($timezoneOrAbbr))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_name(array $r, $timezoneOrName): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_timezone_name($timezoneOrName))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_nameabbr(array $r, $timezoneOrNameOrAbbr): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_timezone_nameabbr($timezoneOrNameOrAbbr))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date(array $r, $datestring, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_date($datestring, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate(array $r, $datestring, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_adate($datestring, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate(array $r, $datestring, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_idate($datestring, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_formatted(array $r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_date_formatted($dateFormatted, $formats, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_formatted(array $r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_adate_formatted($dateFormatted, $formats, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_formatted(array $r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_idate_formatted($dateFormatted, $formats, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_tz(array $r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_date_tz($datestring, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_tz(array $r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_adate_tz($datestring, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_tz(array $r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_idate_tz($datestring, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_tz_formatted(array $r, $dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_date_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_tz_formatted(
		array $r,
		$dateFormatted,
		$formats,
		?array $allowedTimezoneTypes = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_adate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_tz_formatted(
		array $r,
		$dateFormatted,
		$formats,
		?array $allowedTimezoneTypes = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_idate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_microtime(array $r, $microtime, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_date_microtime($microtime, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_microtime(array $r, $microtime, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_adate_microtime($microtime, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_microtime(array $r, $microtime, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_idate_microtime($microtime, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval(array $r, $interval): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_interval($interval))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_duration(array $r, $duration): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_interval_duration($duration))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_datestring(array $r, $datestring): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_interval_datestring($datestring))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_microtime(array $r, $microtime): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_interval_microtime($microtime))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_ago(array $r, $date, ?\DateTimeInterface $from = null, ?bool $reverse = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::date()->type_interval_ago($date, $from, $reverse))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T>, 1?: Ret<class-string<T>> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_exists(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_exists($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T>, 1?: Ret<class-string<T>> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T>, 1?: Ret<class-string<T>> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_class(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_class($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string, 1?: Ret<class-string> } $r
	 */
	public function filter_struct_interface(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_interface($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string, 1?: Ret<class-string> } $r
	 */
	public function filter_struct_trait(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_trait($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T>, 1?: Ret<class-string<T>> } $r
	 *
	 * @template-covariant T of \UnitEnum
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_enum(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_enum($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T>, 1?: Ret<class-string<T>> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_fqcn(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_fqcn($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_struct_namespace(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_namespace($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_struct_basename(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_struct_basename($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_resource(array $r, $value, ?string $resourceType = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_resource($value, $resourceType))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_resource_opened(array $r, $value, ?string $resourceType = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_resource_opened($value, $resourceType))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_resource_closed(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_resource_closed($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_any_not_resource(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_any_not_resource($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource|\CurlHandle, 1?: Ret<resource|\CurlHandle> } $r
	 */
	public function filter_curl(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_curl($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T, 1?: Ret<T> } $r
	 *
	 * @template-covariant T of \UnitEnum
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 */
	public function filter_enum_case(array $r, $value, ?string $enumClass = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_enum_case($value, $enumClass))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: bool, 1?: Ret<bool> } $r
	 *
	 * > метод не всегда callable, поскольку строка 'class->method' не является callable
	 * > метод не всегда callable, поскольку массив [ 'class', 'method' ] не является callable, если метод публичный
	 * > используйте type_callable_string, если собираетесь вызывать метод
	 * > используйте type_callable_array, если собираетесь вызывать метод
	 * @param array{ 0?: array{ 0: class-string, 1: string }, 1?: string } $refs
	 */
	public function filter_method(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_method($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array{ 0: class-string, 1: string }, 1?: Ret<array{ 0: class-string, 1: string }> } $r
	 */
	public function filter_method_array(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_method_array($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_method_string(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_method_string($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable, 1?: Ret<callable> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_object($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|\Closure|object, 1?: Ret<callable|\Closure|object> } $r
	 */
	public function filter_callable_object(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_object($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \Closure, 1?: Ret<\Closure> } $r
	 */
	public function filter_callable_object_closure(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_object_closure($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|object, 1?: Ret<callable|object> } $r
	 */
	public function filter_callable_object_invokable(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_object_invokable($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: object|class-string, 1: string }, 1?: Ret<callable|array{ 0: object|class-string, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_array($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: object|class-string, 1: string }, 1?: Ret<callable|array{ 0: object|class-string, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array_method(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_array_method($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: class-string, 1: string }, 1?: Ret<callable|array{ 0: class-string, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array_method_static(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_array_method_static($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: object, 1: string }, 1?: Ret<callable|array{ 0: object, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array_method_non_static(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_array_method_non_static($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|callable-string, 1?: Ret<callable|callable-string> } $r
	 */
	public function filter_callable_string(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_string($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|callable-string, 1?: Ret<callable|callable-string> } $r
	 */
	public function filter_callable_string_function(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_string_function($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|callable-string, 1?: Ret<callable|callable-string> } $r
	 */
	public function filter_callable_string_function_internal(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_string_function_internal($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|callable-string, 1?: Ret<callable|callable-string> } $r
	 */
	public function filter_callable_string_function_non_internal(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_string_function_non_internal($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|callable-string, 1?: Ret<callable|callable-string> } $r
	 */
	public function filter_callable_string_method_static(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::php()->type_callable_string_method_static($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_chmod(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_chmod($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_path(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_path($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_realpath(array $r, $value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_realpath($value, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_freepath(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_freepath($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_dirpath(
		array $r,
		$value,
		?bool $isAllowExists,
		?bool $isAllowSymlink = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_dirpath($value, $isAllowExists, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_filepath(
		array $r,
		$value,
		?bool $isAllowExists,
		?bool $isAllowSymlink = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_filepath($value, $isAllowExists, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_dirpath_realpath(array $r, $value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_dirpath_realpath($value, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_filepath_realpath(array $r, $value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_filepath_realpath($value, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_filename(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_filename($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \SplFileInfo, 1?: Ret<\SplFileInfo> } $r
	 */
	public function filter_file(
		array $r,
		$value,
		?array $extensions = null,
		?array $mimeTypes = null,
		?array $filters = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_file($value, $extensions, $mimeTypes, $filters))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \SplFileInfo, 1?: Ret<\SplFileInfo> } $r
	 */
	public function filter_image(
		array $r,
		$value,
		?array $extensions = null,
		?array $mimeTypes = null,
		?array $filters = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_image($value, $extensions, $mimeTypes, $filters))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource|\Socket, 1?: Ret<resource|\Socket> } $r
	 */
	public function filter_socket(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_socket($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_stream(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::fs()->type_stream($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_email(array $r, $value, ?array $filters = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_email($value, $filters, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_email_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_email_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_email_non_fake(array $r, $value, ?array $filters = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_email_non_fake($value, $filters, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_phone(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_phone($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_phone_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_phone_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_phone_non_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_phone_non_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string, 3?: string } $refs
	 */
	public function filter_phone_real(array $r, $value, ?string $region = '', array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_phone_real($value, $region, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_tel(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_tel($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_tel_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_tel_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_tel_non_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_tel_non_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_tel_real(array $r, $value, ?string $region = '', array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = Lib::social()->type_tel_real($value, $region, $refs))->isOk([ &$refValue ]);
	}
}
