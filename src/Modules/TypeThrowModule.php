<?php

/**
 * This class is autogenerated.
 */

namespace Gzhegow\Lib\Modules;

use Gzhegow\Lib\Exception\LogicException;
use Gzhegow\Lib\Lib;
use Gzhegow\Lib\Modules\Arr\ArrPath;
use Gzhegow\Lib\Modules\Bcmath\Bcnumber;
use Gzhegow\Lib\Modules\Bcmath\Number;
use Gzhegow\Lib\Modules\Net\AddressIpV4;
use Gzhegow\Lib\Modules\Net\AddressIpV6;
use Gzhegow\Lib\Modules\Net\SubnetV4;
use Gzhegow\Lib\Modules\Net\SubnetV6;
use Gzhegow\Lib\Modules\Php\Nil;
use Gzhegow\Lib\Modules\Str\Alphabet;

class TypeThrowModule
{
	/**
	 * @param mixed|null $r
	 */
	public function empty(&$r, $value): bool
	{
		if (Lib::type()->empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `empty` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_empty(&$r, $value): bool
	{
		if (Lib::type()->any_not_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_empty` is failed", $value ]);
	}


	/**
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 *
	 * @param string|array|\Countable|null $r
	 */
	public function blank(&$r, $value): bool
	{
		if (Lib::type()->blank($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `blank` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_blank(&$r, $value): bool
	{
		if (Lib::type()->any_not_blank($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_blank` is failed", $value ]);
	}


	/**
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 *
	 * @param mixed|null $r
	 */
	public function nullable(&$r, $value): bool
	{
		if (Lib::type()->nullable($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `nullable` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_nullable(&$r, $value): bool
	{
		if (Lib::type()->any_not_nullable($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_nullable` is failed", $value ]);
	}


	/**
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 *
	 * @param mixed|null $r
	 */
	public function passed(&$r, $value): bool
	{
		if (Lib::type()->passed($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `passed` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_passed(&$r, $value): bool
	{
		if (Lib::type()->any_not_passed($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_passed` is failed", $value ]);
	}


	/**
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 *
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 *
	 * @param string|Nil|null $r
	 */
	public function nil(&$r, $value): bool
	{
		if (Lib::type()->nil($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `nil` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_nil(&$r, $value): bool
	{
		if (Lib::type()->any_not_nil($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_nil` is failed", $value ]);
	}


	/**
	 * @param null $r
	 */
	public function a_null(&$r, $value): bool
	{
		if (Lib::type()->a_null($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_null` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_null(&$r, $value): bool
	{
		if (Lib::type()->any_not_null($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_null` is failed", $value ]);
	}


	/**
	 * @param bool|null $r
	 */
	public function a_bool(&$r, $value): bool
	{
		if (Lib::type()->a_bool($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_bool` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function an_any_not_bool(&$r, $value): bool
	{
		if (Lib::type()->an_any_not_bool($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `an_any_not_bool` is failed", $value ]);
	}


	/**
	 * @param false|null $r
	 */
	public function a_false(&$r, $value): bool
	{
		if (Lib::type()->a_false($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_false` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_false(&$r, $value): bool
	{
		if (Lib::type()->any_not_false($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_false` is failed", $value ]);
	}


	/**
	 * @param true|null $r
	 */
	public function a_true(&$r, $value): bool
	{
		if (Lib::type()->a_true($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_true` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_true(&$r, $value): bool
	{
		if (Lib::type()->any_not_true($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_true` is failed", $value ]);
	}


	/**
	 * @param bool|null $r
	 */
	public function bool(&$r, $value): bool
	{
		if (Lib::type()->bool($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `bool` is failed", $value ]);
	}


	/**
	 * @param false|null $r
	 */
	public function false(&$r, $value): bool
	{
		if (Lib::type()->false($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `false` is failed", $value ]);
	}


	/**
	 * @param false|null $r
	 */
	public function true(&$r, $value): bool
	{
		if (Lib::type()->true($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `true` is failed", $value ]);
	}


	/**
	 * @param bool|null $r
	 */
	public function userbool(&$r, $value): bool
	{
		if (Lib::type()->userbool($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `userbool` is failed", $value ]);
	}


	/**
	 * @param false|null $r
	 */
	public function userfalse(&$r, $value): bool
	{
		if (Lib::type()->userfalse($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `userfalse` is failed", $value ]);
	}


	/**
	 * @param false|null $r
	 */
	public function usertrue(&$r, $value): bool
	{
		if (Lib::type()->usertrue($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `usertrue` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function nan(&$r, $value): bool
	{
		if (Lib::type()->nan($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `nan` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_not_nan(&$r, $value): bool
	{
		if (Lib::type()->float_not_nan($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_not_nan` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_nan(&$r, $value): bool
	{
		if (Lib::type()->any_not_nan($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_nan` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function finite(&$r, $value): bool
	{
		if (Lib::type()->finite($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `finite` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_not_finite(&$r, $value): bool
	{
		if (Lib::type()->float_not_finite($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_not_finite` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_finite(&$r, $value): bool
	{
		if (Lib::type()->any_not_finite($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_finite` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function infinite(&$r, $value): bool
	{
		if (Lib::type()->infinite($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `infinite` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_not_infinite(&$r, $value): bool
	{
		if (Lib::type()->float_not_infinite($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_not_infinite` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_infinite(&$r, $value): bool
	{
		if (Lib::type()->any_not_infinite($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_infinite` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_min(&$r, $value): bool
	{
		if (Lib::type()->float_min($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_min` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_not_float_min(&$r, $value): bool
	{
		if (Lib::type()->float_not_float_min($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_not_float_min` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_float_min(&$r, $value): bool
	{
		if (Lib::type()->any_not_float_min($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_float_min` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric(&$r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (Lib::type()->numeric($r, $value, $isAllowExp, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric` is failed", $value, $isAllowExp, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_non_zero(&$r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (Lib::type()->numeric_non_zero($r, $value, $isAllowExp, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_non_zero` is failed", $value, $isAllowExp, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_non_negative(&$r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (Lib::type()->numeric_non_negative($r, $value, $isAllowExp, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_non_negative` is failed", $value, $isAllowExp, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_non_positive(&$r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (Lib::type()->numeric_non_positive($r, $value, $isAllowExp, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_non_positive` is failed", $value, $isAllowExp, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_negative(&$r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (Lib::type()->numeric_negative($r, $value, $isAllowExp, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_negative` is failed", $value, $isAllowExp, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_positive(&$r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (Lib::type()->numeric_positive($r, $value, $isAllowExp, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_positive` is failed", $value, $isAllowExp, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_non_zero(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_non_zero($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_non_zero` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_non_negative(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_non_negative($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_non_negative` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_non_positive(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_non_positive($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_non_positive` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_negative(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_negative($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_negative` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_positive(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_positive($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_positive` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_positive_or_minus_one(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_positive_or_minus_one($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_positive_or_minus_one` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_int_non_negative_or_minus_one(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_int_non_negative_or_minus_one($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_int_non_negative_or_minus_one` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_float(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_float($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_float` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_float_non_zero(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_float_non_zero($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_float_non_zero` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_float_non_negative(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_float_non_negative($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_float_non_negative` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_float_non_positive(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_float_non_positive($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_float_non_positive` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_float_negative(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_float_negative($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_float_negative` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_float_positive(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_float_positive($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_float_positive` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_trimpad(
		&$r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (Lib::type()->numeric_trimpad($r, $value, $lenTrim, $lenPad, $stringPad, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_trimpad` is failed", $value, $lenTrim, $lenPad, $stringPad, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_trimpad_non_zero(
		&$r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (Lib::type()->numeric_trimpad_non_zero($r, $value, $lenTrim, $lenPad, $stringPad, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_trimpad_non_zero` is failed", $value, $lenTrim, $lenPad, $stringPad, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_trimpad_non_negative(
		&$r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (Lib::type()->numeric_trimpad_non_negative($r, $value, $lenTrim, $lenPad, $stringPad, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_trimpad_non_negative` is failed", $value, $lenTrim, $lenPad, $stringPad, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_trimpad_non_positive(
		&$r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (Lib::type()->numeric_trimpad_non_positive($r, $value, $lenTrim, $lenPad, $stringPad, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_trimpad_non_positive` is failed", $value, $lenTrim, $lenPad, $stringPad, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_trimpad_negative(
		&$r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (Lib::type()->numeric_trimpad_negative($r, $value, $lenTrim, $lenPad, $stringPad, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_trimpad_negative` is failed", $value, $lenTrim, $lenPad, $stringPad, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_trimpad_positive(
		&$r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (Lib::type()->numeric_trimpad_positive($r, $value, $lenTrim, $lenPad, $stringPad, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_trimpad_positive` is failed", $value, $lenTrim, $lenPad, $stringPad, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function decimal(&$r, $value, int $scale = 0, array $refs = []): bool
	{
		if (Lib::type()->decimal($r, $value, $scale, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `decimal` is failed", $value, $scale, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function decimal_non_zero(&$r, $value, int $scale = 0, array $refs = []): bool
	{
		if (Lib::type()->decimal_non_zero($r, $value, $scale, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `decimal_non_zero` is failed", $value, $scale, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function decimal_non_negative(&$r, $value, int $scale = 0, array $refs = []): bool
	{
		if (Lib::type()->decimal_non_negative($r, $value, $scale, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `decimal_non_negative` is failed", $value, $scale, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function decimal_non_positive(&$r, $value, int $scale = 0, array $refs = []): bool
	{
		if (Lib::type()->decimal_non_positive($r, $value, $scale, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `decimal_non_positive` is failed", $value, $scale, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function decimal_negative(&$r, $value, int $scale = 0, array $refs = []): bool
	{
		if (Lib::type()->decimal_negative($r, $value, $scale, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `decimal_negative` is failed", $value, $scale, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function decimal_positive(&$r, $value, int $scale = 0, array $refs = []): bool
	{
		if (Lib::type()->decimal_positive($r, $value, $scale, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `decimal_positive` is failed", $value, $scale, $refs ]);
	}


	/**
	 * @param int|float|null $r
	 */
	public function num(&$r, $value): bool
	{
		if (Lib::type()->num($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `num` is failed", $value ]);
	}


	/**
	 * @param int|float|null $r
	 */
	public function num_non_zero(&$r, $value): bool
	{
		if (Lib::type()->num_non_zero($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `num_non_zero` is failed", $value ]);
	}


	/**
	 * @param int|float|null $r
	 */
	public function num_non_negative(&$r, $value): bool
	{
		if (Lib::type()->num_non_negative($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `num_non_negative` is failed", $value ]);
	}


	/**
	 * @param int|float|null $r
	 */
	public function num_non_positive(&$r, $value): bool
	{
		if (Lib::type()->num_non_positive($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `num_non_positive` is failed", $value ]);
	}


	/**
	 * @param int|float|null $r
	 */
	public function num_negative(&$r, $value): bool
	{
		if (Lib::type()->num_negative($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `num_negative` is failed", $value ]);
	}


	/**
	 * @param int|float|null $r
	 */
	public function num_positive(&$r, $value): bool
	{
		if (Lib::type()->num_positive($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `num_positive` is failed", $value ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int(&$r, $value): bool
	{
		if (Lib::type()->int($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int` is failed", $value ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int_non_zero(&$r, $value): bool
	{
		if (Lib::type()->int_non_zero($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_non_zero` is failed", $value ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int_non_negative(&$r, $value): bool
	{
		if (Lib::type()->int_non_negative($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_non_negative` is failed", $value ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int_non_positive(&$r, $value): bool
	{
		if (Lib::type()->int_non_positive($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_non_positive` is failed", $value ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int_negative(&$r, $value): bool
	{
		if (Lib::type()->int_negative($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_negative` is failed", $value ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int_positive(&$r, $value): bool
	{
		if (Lib::type()->int_positive($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_positive` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function int_positive_or_minus_one(&$r, $value): bool
	{
		if (Lib::type()->int_positive_or_minus_one($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_positive_or_minus_one` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function int_non_negative_or_minus_one(&$r, $value): bool
	{
		if (Lib::type()->int_non_negative_or_minus_one($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_non_negative_or_minus_one` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float(&$r, $value): bool
	{
		if (Lib::type()->float($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_non_zero(&$r, $value): bool
	{
		if (Lib::type()->float_non_zero($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_non_zero` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_non_negative(&$r, $value): bool
	{
		if (Lib::type()->float_non_negative($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_non_negative` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_non_positive(&$r, $value): bool
	{
		if (Lib::type()->float_non_positive($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_non_positive` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_negative(&$r, $value): bool
	{
		if (Lib::type()->float_negative($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_negative` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_positive(&$r, $value): bool
	{
		if (Lib::type()->float_positive($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_positive` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_intpart(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_intpart($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_intpart` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function numeric_fracpart(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->numeric_fracpart($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `numeric_fracpart` is failed", $value, $refs ]);
	}


	/**
	 * @param int|null $r
	 */
	public function int_intpart(&$r, $value): bool
	{
		if (Lib::type()->int_intpart($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `int_intpart` is failed", $value ]);
	}


	/**
	 * @param float|null $r
	 */
	public function float_fracpart(&$r, $value): bool
	{
		if (Lib::type()->float_fracpart($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `float_fracpart` is failed", $value ]);
	}


	/**
	 * @param Number|null $r
	 */
	public function number(&$r, $value, ?bool $allowExp = null): bool
	{
		if (Lib::type()->number($r, $value, $allowExp)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `number` is failed", $value, $allowExp ]);
	}


	/**
	 * @param Bcnumber|null $r
	 */
	public function bcnumber(&$r, $value): bool
	{
		if (Lib::type()->bcnumber($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `bcnumber` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function a_string(&$r, $value): bool
	{
		if (Lib::type()->a_string($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_string` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function a_string_empty(&$r, $value): bool
	{
		if (Lib::type()->a_string_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_string_empty` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function a_string_not_empty(&$r, $value): bool
	{
		if (Lib::type()->a_string_not_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_string_not_empty` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function a_trim(&$r, $value): bool
	{
		if (Lib::type()->a_trim($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `a_trim` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function string(&$r, $value): bool
	{
		if (Lib::type()->string($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `string` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function string_empty(&$r, $value): bool
	{
		if (Lib::type()->string_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `string_empty` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function string_not_empty(&$r, $value): bool
	{
		if (Lib::type()->string_not_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `string_not_empty` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function trim(&$r, $value, ?string $characters = null): bool
	{
		if (Lib::type()->trim($r, $value, $characters)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `trim` is failed", $value, $characters ]);
	}


	/**
	 * @param string|null $r
	 */
	public function char(&$r, $value): bool
	{
		if (Lib::type()->char($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `char` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function letter(&$r, $value): bool
	{
		if (Lib::type()->letter($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `letter` is failed", $value ]);
	}


	/**
	 * @param Alphabet|null $r
	 */
	public function alphabet(&$r, $value): bool
	{
		if (Lib::type()->alphabet($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `alphabet` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function ctype_digit(&$r, $value): bool
	{
		if (Lib::type()->ctype_digit($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `ctype_digit` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function ctype_alpha(&$r, $value, ?bool $isIgnoreCase = null): bool
	{
		if (Lib::type()->ctype_alpha($r, $value, $isIgnoreCase)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `ctype_alpha` is failed", $value, $isIgnoreCase ]);
	}


	/**
	 * @param string|null $r
	 */
	public function ctype_alnum(&$r, $value, ?bool $isIgnoreCase = null): bool
	{
		if (Lib::type()->ctype_alnum($r, $value, $isIgnoreCase)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `ctype_alnum` is failed", $value, $isIgnoreCase ]);
	}


	/**
	 * @param string|null $r
	 */
	public function base(&$r, $value, $alphabet): bool
	{
		if (Lib::type()->base($r, $value, $alphabet)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `base` is failed", $value, $alphabet ]);
	}


	/**
	 * @param string|null $r
	 */
	public function base_bin(&$r, $value): bool
	{
		if (Lib::type()->base_bin($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `base_bin` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function base_oct(&$r, $value): bool
	{
		if (Lib::type()->base_oct($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `base_oct` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function base_dec(&$r, $value): bool
	{
		if (Lib::type()->base_dec($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `base_dec` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function base_hex(&$r, $value): bool
	{
		if (Lib::type()->base_hex($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `base_hex` is failed", $value ]);
	}


	/**
	 * @param array|null $r
	 */
	public function array_empty(&$r, $value): bool
	{
		if (Lib::type()->array_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_empty` is failed", $value ]);
	}


	/**
	 * @param array|null $r
	 */
	public function array_not_empty(&$r, $value): bool
	{
		if (Lib::type()->array_not_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_not_empty` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function any_not_array_empty(&$r, $value): bool
	{
		if (Lib::type()->any_not_array_empty($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_array_empty` is failed", $value ]);
	}


	/**
	 * @param mixed|null $r
	 */
	public function key_exists(&$r, $value, $key): bool
	{
		if (Lib::type()->key_exists($r, $value, $key)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `key_exists` is failed", $value, $key ]);
	}


	/**
	 * @param array|null $r
	 */
	public function array_plain(&$r, $value): bool
	{
		if (Lib::type()->array_plain($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_plain` is failed", $value ]);
	}


	/**
	 * @param array|null $r
	 */
	public function list(&$r, $value, ?bool $isPlain = null): bool
	{
		if (Lib::type()->list($r, $value, $isPlain)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `list` is failed", $value, $isPlain ]);
	}


	/**
	 * @param array|null $r
	 */
	public function list_sorted(&$r, $value, ?bool $isPlain = null): bool
	{
		if (Lib::type()->list_sorted($r, $value, $isPlain)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `list_sorted` is failed", $value, $isPlain ]);
	}


	/**
	 * @param array|null $r
	 */
	public function dict(&$r, $value, ?bool $isPlain = null): bool
	{
		if (Lib::type()->dict($r, $value, $isPlain)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `dict` is failed", $value, $isPlain ]);
	}


	/**
	 * @param array|null $r
	 */
	public function dict_sorted(&$r, $value, ?bool $isPlain = null): bool
	{
		if (Lib::type()->dict_sorted($r, $value, $isPlain)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `dict_sorted` is failed", $value, $isPlain ]);
	}


	/**
	 * @param array|null $r
	 */
	public function table(&$r, $value): bool
	{
		if (Lib::type()->table($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `table` is failed", $value ]);
	}


	/**
	 * @param array|null $r
	 */
	public function matrix(&$r, $value): bool
	{
		if (Lib::type()->matrix($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `matrix` is failed", $value ]);
	}


	/**
	 * @param array|null $r
	 */
	public function matrix_strict(&$r, $value): bool
	{
		if (Lib::type()->matrix_strict($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `matrix_strict` is failed", $value ]);
	}


	/**
	 * @param ArrPath|null $r
	 */
	public function arrpath(&$r, $path, ?string $dot = null): bool
	{
		if (Lib::type()->arrpath($r, $path, $dot)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `arrpath` is failed", $path, $dot ]);
	}


	/**
	 * @param array|null $r
	 */
	public function array_of_type(&$r, $value, string $type): bool
	{
		if (Lib::type()->array_of_type($r, $value, $type)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_of_type` is failed", $value, $type ]);
	}


	/**
	 * @param resource[]|null $r
	 */
	public function array_of_resource_type(&$r, $value, string $resourceType): bool
	{
		if (Lib::type()->array_of_resource_type($r, $value, $resourceType)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_of_resource_type` is failed", $value, $resourceType ]);
	}


	/**
	 * @template T
	 *
	 * @param T[]             $r
	 * @param class-string<T> $className
	 */
	public function array_of_a(&$r, $value, string $className): bool
	{
		if (Lib::type()->array_of_a($r, $value, $className)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_of_a` is failed", $value, $className ]);
	}


	/**
	 * @template T
	 *
	 * @param T[]             $r
	 * @param class-string<T> $className
	 */
	public function array_of_class(&$r, $value, string $className): bool
	{
		if (Lib::type()->array_of_class($r, $value, $className)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_of_class` is failed", $value, $className ]);
	}


	/**
	 * @template T
	 *
	 * @param T[]             $r
	 * @param class-string<T> $className
	 */
	public function array_of_subclass(&$r, $value, string $className): bool
	{
		if (Lib::type()->array_of_subclass($r, $value, $className)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_of_subclass` is failed", $value, $className ]);
	}


	/**
	 * @param array|null $r
	 */
	public function array_of_callback(&$r, $value, callable $fn, array $args = []): bool
	{
		if (Lib::type()->array_of_callback($r, $value, $fn, $args)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `array_of_callback` is failed", $value, $fn, $args ]);
	}


	/**
	 * @param string|null $r
	 */
	public function html_tag(&$r, $value): bool
	{
		if (Lib::type()->html_tag($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `html_tag` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function xml_tag(&$r, $value): bool
	{
		if (Lib::type()->xml_tag($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `xml_tag` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function xml_nstag(&$r, $value): bool
	{
		if (Lib::type()->xml_nstag($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `xml_nstag` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function regex(&$r, $value): bool
	{
		if (Lib::type()->regex($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `regex` is failed", $value ]);
	}


	/**
	 * @param AddressIpV4|AddressIpV6|null $r
	 */
	public function address_ip(&$r, $value): bool
	{
		if (Lib::type()->address_ip($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `address_ip` is failed", $value ]);
	}


	/**
	 * @param AddressIpV4|null $r
	 */
	public function address_ip_v4(&$r, $value): bool
	{
		if (Lib::type()->address_ip_v4($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `address_ip_v4` is failed", $value ]);
	}


	/**
	 * @param AddressIpV6|null $r
	 */
	public function address_ip_v6(&$r, $value): bool
	{
		if (Lib::type()->address_ip_v6($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `address_ip_v6` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function address_mac(&$r, $value): bool
	{
		if (Lib::type()->address_mac($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `address_mac` is failed", $value ]);
	}


	/**
	 * @param SubnetV4|SubnetV6|null $r
	 */
	public function subnet(&$r, $value, ?string $ipFallback = null): bool
	{
		if (Lib::type()->subnet($r, $value, $ipFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `subnet` is failed", $value, $ipFallback ]);
	}


	/**
	 * @param SubnetV4|null $r
	 */
	public function subnet_v4(&$r, $value, ?string $ipFallback = null): bool
	{
		if (Lib::type()->subnet_v4($r, $value, $ipFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `subnet_v4` is failed", $value, $ipFallback ]);
	}


	/**
	 * @param SubnetV6|null $r
	 */
	public function subnet_v6(&$r, $value, ?string $ipFallback = null): bool
	{
		if (Lib::type()->subnet_v6($r, $value, $ipFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `subnet_v6` is failed", $value, $ipFallback ]);
	}


	/**
	 * @param string|null $r
	 */
	public function url(&$r, $value, $query = null, $fragment = null, array $refs = []): bool
	{
		if (Lib::type()->url($r, $value, $query, $fragment, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `url` is failed", $value, $query, $fragment, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function host(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->host($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `host` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function link(&$r, $value, $query = null, $fragment = null, array $refs = []): bool
	{
		if (Lib::type()->link($r, $value, $query, $fragment, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `link` is failed", $value, $query, $fragment, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function uuid(&$r, $value): bool
	{
		if (Lib::type()->uuid($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `uuid` is failed", $value ]);
	}


	/**
	 * @param array|\Countable|null $r
	 */
	public function countable(&$r, $value): bool
	{
		if (Lib::type()->countable($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `countable` is failed", $value ]);
	}


	/**
	 * @param \Countable|null $r
	 */
	public function countable_object(&$r, $value): bool
	{
		if (Lib::type()->countable_object($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `countable_object` is failed", $value ]);
	}


	/**
	 * @param string|array|\Countable|null $r
	 */
	public function sizeable(&$r, $value): bool
	{
		if (Lib::type()->sizeable($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `sizeable` is failed", $value ]);
	}


	/**
	 * @param \DateTimeZone|null $r
	 */
	public function timezone(&$r, $timezone, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->timezone($r, $timezone, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `timezone` is failed", $timezone, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTimeZone|null $r
	 */
	public function timezone_offset(&$r, $timezoneOrOffset): bool
	{
		if (Lib::type()->timezone_offset($r, $timezoneOrOffset)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `timezone_offset` is failed", $timezoneOrOffset ]);
	}


	/**
	 * @param \DateTimeZone|null $r
	 */
	public function timezone_abbr(&$r, $timezoneOrAbbr): bool
	{
		if (Lib::type()->timezone_abbr($r, $timezoneOrAbbr)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `timezone_abbr` is failed", $timezoneOrAbbr ]);
	}


	/**
	 * @param \DateTimeZone|null $r
	 */
	public function timezone_name(&$r, $timezoneOrName): bool
	{
		if (Lib::type()->timezone_name($r, $timezoneOrName)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `timezone_name` is failed", $timezoneOrName ]);
	}


	/**
	 * @param \DateTimeZone|null $r
	 */
	public function timezone_nameabbr(&$r, $timezoneOrNameOrAbbr): bool
	{
		if (Lib::type()->timezone_nameabbr($r, $timezoneOrNameOrAbbr)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `timezone_nameabbr` is failed", $timezoneOrNameOrAbbr ]);
	}


	/**
	 * @param \DateTimeInterface|null $r
	 */
	public function date(&$r, $datestring, $timezoneFallback = null): bool
	{
		if (Lib::type()->date($r, $datestring, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `date` is failed", $datestring, $timezoneFallback ]);
	}


	/**
	 * @param \DateTime|null $r
	 */
	public function adate(&$r, $datestring, $timezoneFallback = null): bool
	{
		if (Lib::type()->adate($r, $datestring, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `adate` is failed", $datestring, $timezoneFallback ]);
	}


	/**
	 * @param \DateTimeImmutable|null $r
	 */
	public function idate(&$r, $datestring, $timezoneFallback = null): bool
	{
		if (Lib::type()->idate($r, $datestring, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `idate` is failed", $datestring, $timezoneFallback ]);
	}


	/**
	 * @param \DateTimeInterface|null $r
	 */
	public function date_formatted(&$r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (Lib::type()->date_formatted($r, $dateFormatted, $formats, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `date_formatted` is failed", $dateFormatted, $formats, $timezoneFallback ]);
	}


	/**
	 * @param \DateTime|null $r
	 */
	public function adate_formatted(&$r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (Lib::type()->adate_formatted($r, $dateFormatted, $formats, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `adate_formatted` is failed", $dateFormatted, $formats, $timezoneFallback ]);
	}


	/**
	 * @param \DateTimeImmutable|null $r
	 */
	public function idate_formatted(&$r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (Lib::type()->idate_formatted($r, $dateFormatted, $formats, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `idate_formatted` is failed", $dateFormatted, $formats, $timezoneFallback ]);
	}


	/**
	 * @param \DateTimeInterface|null $r
	 */
	public function date_tz(&$r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->date_tz($r, $datestring, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `date_tz` is failed", $datestring, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTime|null $r
	 */
	public function adate_tz(&$r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->adate_tz($r, $datestring, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `adate_tz` is failed", $datestring, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTimeImmutable|null $r
	 */
	public function idate_tz(&$r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->idate_tz($r, $datestring, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `idate_tz` is failed", $datestring, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTimeInterface|null $r
	 */
	public function date_tz_formatted(&$r, $dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->date_tz_formatted($r, $dateFormatted, $formats, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `date_tz_formatted` is failed", $dateFormatted, $formats, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTime|null $r
	 */
	public function adate_tz_formatted(&$r, $dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->adate_tz_formatted($r, $dateFormatted, $formats, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `adate_tz_formatted` is failed", $dateFormatted, $formats, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTimeImmutable|null $r
	 */
	public function idate_tz_formatted(&$r, $dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		if (Lib::type()->idate_tz_formatted($r, $dateFormatted, $formats, $allowedTimezoneTypes)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `idate_tz_formatted` is failed", $dateFormatted, $formats, $allowedTimezoneTypes ]);
	}


	/**
	 * @param \DateTimeInterface|null $r
	 */
	public function date_microtime(&$r, $microtime, $timezoneFallback = null): bool
	{
		if (Lib::type()->date_microtime($r, $microtime, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `date_microtime` is failed", $microtime, $timezoneFallback ]);
	}


	/**
	 * @param \DateTime|null $r
	 */
	public function adate_microtime(&$r, $microtime, $timezoneFallback = null): bool
	{
		if (Lib::type()->adate_microtime($r, $microtime, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `adate_microtime` is failed", $microtime, $timezoneFallback ]);
	}


	/**
	 * @param \DateTimeImmutable|null $r
	 */
	public function idate_microtime(&$r, $microtime, $timezoneFallback = null): bool
	{
		if (Lib::type()->idate_microtime($r, $microtime, $timezoneFallback)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `idate_microtime` is failed", $microtime, $timezoneFallback ]);
	}


	/**
	 * @param \DateInterval|null $r
	 */
	public function interval(&$r, $interval): bool
	{
		if (Lib::type()->interval($r, $interval)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `interval` is failed", $interval ]);
	}


	/**
	 * @param \DateInterval|null $r
	 */
	public function interval_duration(&$r, $duration): bool
	{
		if (Lib::type()->interval_duration($r, $duration)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `interval_duration` is failed", $duration ]);
	}


	/**
	 * @param \DateInterval|null $r
	 */
	public function interval_datestring(&$r, $datestring): bool
	{
		if (Lib::type()->interval_datestring($r, $datestring)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `interval_datestring` is failed", $datestring ]);
	}


	/**
	 * @param \DateInterval|null $r
	 */
	public function interval_microtime(&$r, $microtime): bool
	{
		if (Lib::type()->interval_microtime($r, $microtime)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `interval_microtime` is failed", $microtime ]);
	}


	/**
	 * @param \DateInterval|null $r
	 */
	public function interval_ago(&$r, $date, ?\DateTimeInterface $from = null, ?bool $reverse = null): bool
	{
		if (Lib::type()->interval_ago($r, $date, $from, $reverse)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `interval_ago` is failed", $date, $from, $reverse ]);
	}


	/**
	 * @template-covariant T of object
	 *
	 * @param class-string<T>|null    $r
	 * @param class-string<T>|T|mixed $value
	 */
	public function struct_exists(&$r, $value, ?int $flags = null)
	{
		if (Lib::type()->struct_exists($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_exists` is failed", $value, $flags ]);
	}


	/**
	 * @template-covariant T of object
	 *
	 * @param class-string<T>|null    $r
	 * @param class-string<T>|T|mixed $value
	 */
	public function struct(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct` is failed", $value, $flags ]);
	}


	/**
	 * @template-covariant T of object
	 *
	 * @param class-string<T>|null    $r
	 * @param class-string<T>|T|mixed $value
	 */
	public function struct_class(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_class($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_class` is failed", $value, $flags ]);
	}


	/**
	 * @param class-string|null $r
	 */
	public function struct_interface(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_interface($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_interface` is failed", $value, $flags ]);
	}


	/**
	 * @param class-string|null $r
	 */
	public function struct_trait(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_trait($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_trait` is failed", $value, $flags ]);
	}


	/**
	 * @template-covariant T of \UnitEnum
	 *
	 * @param class-string<T>|null    $r
	 * @param class-string<T>|T|mixed $value
	 */
	public function struct_enum(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_enum($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_enum` is failed", $value, $flags ]);
	}


	/**
	 * @template-covariant T of object
	 *
	 * @param class-string<T>|null    $r
	 * @param class-string<T>|T|mixed $value
	 */
	public function struct_fqcn(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_fqcn($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_fqcn` is failed", $value, $flags ]);
	}


	/**
	 * @param string|null $r
	 */
	public function struct_namespace(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_namespace($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_namespace` is failed", $value, $flags ]);
	}


	/**
	 * @param string|null $r
	 */
	public function struct_basename(&$r, $value, ?int $flags = null): bool
	{
		if (Lib::type()->struct_basename($r, $value, $flags)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `struct_basename` is failed", $value, $flags ]);
	}


	/**
	 * @param resource|null $r
	 */
	public function resource(&$r, $value, ?string $resourceType = null): bool
	{
		if (Lib::type()->resource($r, $value, $resourceType)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `resource` is failed", $value, $resourceType ]);
	}


	/**
	 * @param resource|null $r
	 */
	public function resource_opened(&$r, $value, ?string $resourceType = null): bool
	{
		if (Lib::type()->resource_opened($r, $value, $resourceType)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `resource_opened` is failed", $value, $resourceType ]);
	}


	/**
	 * @param resource|null $r
	 */
	public function resource_closed(&$r, $value): bool
	{
		if (Lib::type()->resource_closed($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `resource_closed` is failed", $value ]);
	}


	/**
	 * @param resource|null $r
	 */
	public function any_not_resource(&$r, $value): bool
	{
		if (Lib::type()->any_not_resource($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `any_not_resource` is failed", $value ]);
	}


	/**
	 * @param resource|\CurlHandle|null $r
	 */
	public function curl(&$r, $value): bool
	{
		if (Lib::type()->curl($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `curl` is failed", $value ]);
	}


	/**
	 * @param resource|\Socket|null $r
	 */
	public function socket(&$r, $value): bool
	{
		if (Lib::type()->socket($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `socket` is failed", $value ]);
	}


	/**
	 * @template-covariant T of \UnitEnum
	 *
	 * @param T|null               $r
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 */
	public function enum_case(&$r, $value, ?string $enumClass = null): bool
	{
		if (Lib::type()->enum_case($r, $value, $enumClass)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `enum_case` is failed", $value, $enumClass ]);
	}


	/**
	 * @param array{ 0: class-string, 1: string }|null $r
	 */
	public function method_array(&$r, $value): bool
	{
		if (Lib::type()->method_array($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `method_array` is failed", $value ]);
	}


	/**
	 * @param string|null $r
	 */
	public function method_string(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->method_string($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `method_string` is failed", $value, $refs ]);
	}


	/**
	 * @param callable|null $r
	 * @param string|object $newScope
	 */
	public function callable(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|\Closure|object|null $r
	 */
	public function callable_object(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_object($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_object` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|object|null $r
	 */
	public function callable_object_closure(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_object_closure($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_object_closure` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|object|null $r
	 */
	public function callable_object_invokable(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_object_invokable($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_object_invokable` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|array{ 0: object|class-string, 1: string }|null $r
	 * @param string|object                                            $newScope
	 */
	public function callable_array(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_array($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_array` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|array{ 0: object|class-string, 1: string }|null $r
	 * @param string|object                                            $newScope
	 */
	public function callable_array_method(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_array_method($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_array_method` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|array{ 0: class-string, 1: string }|null $r
	 * @param string|object                                     $newScope
	 */
	public function callable_array_method_static(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_array_method_static($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_array_method_static` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable|array{ 0: object, 1: string }|null $r
	 * @param string|object                               $newScope
	 */
	public function callable_array_method_non_static(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_array_method_non_static($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_array_method_non_static` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable-string|null $r
	 */
	public function callable_string(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_string($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_string` is failed", $value, $newScope ]);
	}


	/**
	 * @param callable-string|null $r
	 */
	public function callable_string_function(&$r, $value): bool
	{
		if (Lib::type()->callable_string_function($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_string_function` is failed", $value ]);
	}


	/**
	 * @param callable-string|null $r
	 */
	public function callable_string_function_internal(&$r, $value): bool
	{
		if (Lib::type()->callable_string_function_internal($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_string_function_internal` is failed", $value ]);
	}


	/**
	 * @param callable-string|null $r
	 */
	public function callable_string_function_non_internal(&$r, $value): bool
	{
		if (Lib::type()->callable_string_function_non_internal($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_string_function_non_internal` is failed", $value ]);
	}


	/**
	 * @param callable-string|null $r
	 */
	public function callable_string_method_static(&$r, $value, $newScope = 'static'): bool
	{
		if (Lib::type()->callable_string_method_static($r, $value, $newScope)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `callable_string_method_static` is failed", $value, $newScope ]);
	}


	/**
	 * @template T
	 *
	 * @param mixed|T        $r
	 * @param int|string     $key
	 * @param array{ 0?: T } $set
	 */
	public function ref(&$r, $key, array $refs = [], array $set = []): bool
	{
		if (Lib::type()->ref($r, $key, $refs, $set)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `ref` is failed", $key, $refs, $set ]);
	}


	/**
	 * @param int|null $r
	 * @param string   $value
	 */
	public function chmod(&$r, $value): bool
	{
		if (Lib::type()->chmod($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `chmod` is failed", $value ]);
	}


	/**
	 * @param string|null            $r
	 * @param array{ 0: array|null } $refs
	 */
	public function path(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->path($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `path` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function realpath(&$r, $value, ?bool $allowSymlink = null, array $refs = []): bool
	{
		if (Lib::type()->realpath($r, $value, $allowSymlink, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `realpath` is failed", $value, $allowSymlink, $refs ]);
	}


	/**
	 * @param string|null            $r
	 * @param array{ 0: array|null } $refs
	 */
	public function freepath(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->freepath($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `freepath` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function dirpath(&$r, $value, ?bool $allowExists = null, ?bool $allowSymlink = null, array $refs = []): bool
	{
		if (Lib::type()->dirpath($r, $value, $allowExists, $allowSymlink, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `dirpath` is failed", $value, $allowExists, $allowSymlink, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function filepath(&$r, $value, ?bool $allowExists, ?bool $allowSymlink = null, array $refs = []): bool
	{
		if (Lib::type()->filepath($r, $value, $allowExists, $allowSymlink, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `filepath` is failed", $value, $allowExists, $allowSymlink, $refs ]);
	}


	/**
	 * @param string|null            $r
	 * @param array{ 0: array|null } $refs
	 */
	public function dirpath_realpath(&$r, $value, ?bool $allowSymlink = null, array $refs = []): bool
	{
		if (Lib::type()->dirpath_realpath($r, $value, $allowSymlink, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `dirpath_realpath` is failed", $value, $allowSymlink, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function filepath_realpath(&$r, $value, ?bool $allowSymlink = null, array $refs = []): bool
	{
		if (Lib::type()->filepath_realpath($r, $value, $allowSymlink, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `filepath_realpath` is failed", $value, $allowSymlink, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function filename(&$r, $value): bool
	{
		if (Lib::type()->filename($r, $value)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `filename` is failed", $value ]);
	}


	/**
	 * @param \SplFileInfo|null $r
	 */
	public function file(&$r, $value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null): bool
	{
		if (Lib::type()->file($r, $value, $extensions, $mimeTypes, $filters)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `file` is failed", $value, $extensions, $mimeTypes, $filters ]);
	}


	/**
	 * @param \SplFileInfo|null $r
	 */
	public function image(&$r, $value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null): bool
	{
		if (Lib::type()->image($r, $value, $extensions, $mimeTypes, $filters)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `image` is failed", $value, $extensions, $mimeTypes, $filters ]);
	}


	/**
	 * @param string|null $r
	 */
	public function email(&$r, $value, ?array $filters = null, array $refs = []): bool
	{
		if (Lib::type()->email($r, $value, $filters, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `email` is failed", $value, $filters, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function email_fake(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->email_fake($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `email_fake` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function email_non_fake(&$r, $value, ?array $filters = null, array $refs = []): bool
	{
		if (Lib::type()->email_non_fake($r, $value, $filters, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `email_non_fake` is failed", $value, $filters, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function phone(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->phone($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `phone` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function phone_fake(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->phone_fake($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `phone_fake` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function phone_non_fake(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->phone_non_fake($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `phone_non_fake` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function phone_real(&$r, $value, ?string $region = '', array $refs = []): bool
	{
		if (Lib::type()->phone_real($r, $value, $region, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `phone_real` is failed", $value, $region, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function tel(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->tel($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `tel` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function tel_fake(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->tel_fake($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `tel_fake` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function tel_non_fake(&$r, $value, array $refs = []): bool
	{
		if (Lib::type()->tel_non_fake($r, $value, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `tel_non_fake` is failed", $value, $refs ]);
	}


	/**
	 * @param string|null $r
	 */
	public function tel_real(&$r, $value, ?string $region = '', array $refs = []): bool
	{
		if (Lib::type()->tel_real($r, $value, $region, $refs)) {
		    return true;
		}

		throw new LogicException([ "Typecheck `tel_real` is failed", $value, $region, $refs ]);
	}
}
