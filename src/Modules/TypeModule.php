<?php

/**
 * This class is autogenerated.
 */

namespace Gzhegow\Lib\Modules;

use Gzhegow\Lib\Exception\LogicException;
use Gzhegow\Lib\Modules\Arr\ArrPath;
use Gzhegow\Lib\Modules\Bcmath\Bcnumber;
use Gzhegow\Lib\Modules\Bcmath\Number;
use Gzhegow\Lib\Modules\Net\AddressIpV4;
use Gzhegow\Lib\Modules\Net\AddressIpV6;
use Gzhegow\Lib\Modules\Net\SubnetV4;
use Gzhegow\Lib\Modules\Net\SubnetV6;
use Gzhegow\Lib\Modules\Php\Nil;
use Gzhegow\Lib\Modules\Str\Alphabet;
use Gzhegow\Lib\Modules\Type\Ret;

class TypeModule extends Type\TypeModuleBase
{
	public function is_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_empty($value)->isOk();
	}


	public function is_any_not_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_empty($value)->isOk();
	}


	/**
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 */
	public function is_blank($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_blank($value)->isOk();
	}


	public function is_any_not_blank($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_blank($value)->isOk();
	}


	/**
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 */
	public function is_nullable($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_nullable($value)->isOk();
	}


	public function is_any_not_nullable($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_nullable($value)->isOk();
	}


	/**
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 */
	public function is_passed($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_passed($value)->isOk();
	}


	public function is_any_not_passed($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_passed($value)->isOk();
	}


	/**
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 */
	public function is_nil($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_nil($value)->isOk();
	}


	public function is_any_not_nil($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_nil($value)->isOk();
	}


	public function is_null($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_null($value)->isOk();
	}


	public function is_any_not_null($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_null($value)->isOk();
	}


	public function is_false($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_false($value)->isOk();
	}


	public function is_any_not_false($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_false($value)->isOk();
	}


	public function is_true($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_true($value)->isOk();
	}


	public function is_any_not_true($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_true($value)->isOk();
	}


	public function is_bool($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_bool($value)->isOk();
	}


	public function is_boolfalse($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_boolfalse($value)->isOk();
	}


	public function is_booltrue($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_booltrue($value)->isOk();
	}


	public function is_userbool($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_userbool($value)->isOk();
	}


	public function is_userfalse($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_userfalse($value)->isOk();
	}


	public function is_usertrue($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_usertrue($value)->isOk();
	}


	public function is_array($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_array($value)->isOk();
	}


	public function is_array_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_array_empty($value)->isOk();
	}


	public function is_array_not_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_array_not_empty($value)->isOk();
	}


	public function is_any_not_array_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_array_empty($value)->isOk();
	}


	public function is_any_not_array($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_array($value)->isOk();
	}


	public function is_object($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_object($value)->isOk();
	}


	public function is_any_not_object($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_object($value)->isOk();
	}


	public function is_stdclass($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_stdclass($value)->isOk();
	}


	public function is_any_not_stdclass($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_stdclass($value)->isOk();
	}


	public function is_nan($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_nan($value)->isOk();
	}


	public function is_float_not_nan($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_not_nan($value)->isOk();
	}


	public function is_any_not_nan($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_any_not_nan($value)->isOk();
	}


	public function is_finite($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_finite($value)->isOk();
	}


	public function is_float_not_finite($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_not_finite($value)->isOk();
	}


	public function is_any_not_finite($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_any_not_finite($value)->isOk();
	}


	public function is_infinite($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_infinite($value)->isOk();
	}


	public function is_float_not_infinite($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_not_infinite($value)->isOk();
	}


	public function is_any_not_infinite($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_any_not_infinite($value)->isOk();
	}


	public function is_float_min($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_min($value)->isOk();
	}


	public function is_float_not_float_min($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_not_float_min($value)->isOk();
	}


	public function is_any_not_float_min($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_any_not_float_min($value)->isOk();
	}


	public function is_number($value, ?bool $allowExp = null): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_number($value, $allowExp)->isOk();
	}


	public function is_numeric($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_non_zero($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_non_zero($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_non_negative($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_non_negative($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_non_positive($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_non_positive($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_negative($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_negative($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_positive($value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_positive($value, $isAllowExp, $refs)->isOk();
	}


	public function is_numeric_int($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int($value, $refs)->isOk();
	}


	public function is_numeric_int_non_zero($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_non_zero($value, $refs)->isOk();
	}


	public function is_numeric_int_non_negative($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_non_negative($value, $refs)->isOk();
	}


	public function is_numeric_int_non_positive($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_non_positive($value, $refs)->isOk();
	}


	public function is_numeric_int_negative($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_negative($value, $refs)->isOk();
	}


	public function is_numeric_int_positive($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_positive($value, $refs)->isOk();
	}


	public function is_numeric_int_positive_or_minus_one($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_positive_or_minus_one($value, $refs)->isOk();
	}


	public function is_numeric_int_non_negative_or_minus_one($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_int_non_negative_or_minus_one($value, $refs)->isOk();
	}


	public function is_numeric_float($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_float($value, $refs)->isOk();
	}


	public function is_numeric_float_non_zero($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_float_non_zero($value, $refs)->isOk();
	}


	public function is_numeric_float_non_negative($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_float_non_negative($value, $refs)->isOk();
	}


	public function is_numeric_float_non_positive($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_float_non_positive($value, $refs)->isOk();
	}


	public function is_numeric_float_negative($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_float_negative($value, $refs)->isOk();
	}


	public function is_numeric_float_positive($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_numeric_float_positive($value, $refs)->isOk();
	}


	public function is_numeric_trimpad(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$num->type_numeric_trimpad($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_non_zero(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_zero($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_non_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_non_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_numeric_trimpad_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk();
	}


	public function is_decimal($value, int $scale = 0, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_decimal($value, $scale, $refs)->isOk();
	}


	public function is_decimal_non_zero($value, int $scale = 0, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_decimal_non_zero($value, $scale, $refs)->isOk();
	}


	public function is_decimal_non_negative($value, int $scale = 0, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_decimal_non_negative($value, $scale, $refs)->isOk();
	}


	public function is_decimal_non_positive($value, int $scale = 0, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_decimal_non_positive($value, $scale, $refs)->isOk();
	}


	public function is_decimal_negative($value, int $scale = 0, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_decimal_negative($value, $scale, $refs)->isOk();
	}


	public function is_decimal_positive($value, int $scale = 0, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_decimal_positive($value, $scale, $refs)->isOk();
	}


	public function is_num($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_num($value)->isOk();
	}


	public function is_num_non_zero($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_num_non_zero($value)->isOk();
	}


	public function is_num_non_negative($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_num_non_negative($value)->isOk();
	}


	public function is_num_non_positive($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_num_non_positive($value)->isOk();
	}


	public function is_num_negative($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_num_negative($value)->isOk();
	}


	public function is_num_positive($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_num_positive($value)->isOk();
	}


	public function is_int($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int($value)->isOk();
	}


	public function is_int_non_zero($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_non_zero($value)->isOk();
	}


	public function is_int_non_negative($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_non_negative($value)->isOk();
	}


	public function is_int_non_positive($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_non_positive($value)->isOk();
	}


	public function is_int_negative($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_negative($value)->isOk();
	}


	public function is_int_positive($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_positive($value)->isOk();
	}


	public function is_int_positive_or_minus_one($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_positive_or_minus_one($value)->isOk();
	}


	public function is_int_non_negative_or_minus_one($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_int_non_negative_or_minus_one($value)->isOk();
	}


	public function is_float($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float($value)->isOk();
	}


	public function is_float_non_zero($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_non_zero($value)->isOk();
	}


	public function is_float_non_negative($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_non_negative($value)->isOk();
	}


	public function is_float_non_positive($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_non_positive($value)->isOk();
	}


	public function is_float_negative($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_negative($value)->isOk();
	}


	public function is_float_positive($value): bool
	{
		return \Gzhegow\Lib\Lib::$num->type_float_positive($value)->isOk();
	}


	public function is_bcnumber($value): bool
	{
		return \Gzhegow\Lib\Lib::$bcmath->type_bcnumber($value)->isOk();
	}


	public function is_a_string($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_a_string($value)->isOk();
	}


	public function is_a_string_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_a_string_empty($value)->isOk();
	}


	public function is_a_string_not_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_a_string_not_empty($value)->isOk();
	}


	public function is_a_trim($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_a_trim($value)->isOk();
	}


	public function is_string($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_string($value)->isOk();
	}


	public function is_string_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_string_empty($value)->isOk();
	}


	public function is_string_not_empty($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_string_not_empty($value)->isOk();
	}


	public function is_trim($value, ?string $characters = null): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_trim($value, $characters)->isOk();
	}


	public function is_char($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_char($value)->isOk();
	}


	public function is_letter($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_letter($value)->isOk();
	}


	public function is_word($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_word($value)->isOk();
	}


	public function is_alphabet($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_alphabet($value)->isOk();
	}


	public function is_ctype_digit($value): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_ctype_digit($value)->isOk();
	}


	public function is_ctype_alpha($value, ?bool $allowUpperCase = null): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_ctype_alpha($value, $allowUpperCase)->isOk();
	}


	public function is_ctype_alnum($value, ?bool $allowUpperCase = null): bool
	{
		return \Gzhegow\Lib\Lib::$str->type_ctype_alnum($value, $allowUpperCase)->isOk();
	}


	public function is_base($value, $alphabet): bool
	{
		return \Gzhegow\Lib\Lib::$crypt->type_base($value, $alphabet)->isOk();
	}


	public function is_base_bin($value): bool
	{
		return \Gzhegow\Lib\Lib::$crypt->type_base_bin($value)->isOk();
	}


	public function is_base_oct($value): bool
	{
		return \Gzhegow\Lib\Lib::$crypt->type_base_oct($value)->isOk();
	}


	public function is_base_dec($value): bool
	{
		return \Gzhegow\Lib\Lib::$crypt->type_base_dec($value)->isOk();
	}


	public function is_base_hex($value): bool
	{
		return \Gzhegow\Lib\Lib::$crypt->type_base_hex($value)->isOk();
	}


	public function is_key($key): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_key($key)->isOk();
	}


	public function is_key_exists($key, array $array): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_key_exists($key, $array)->isOk();
	}


	public function is_key_not_exists($key, array $array): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_key_not_exists($key, $array)->isOk();
	}


	public function is_array_plain($value, ?int $maxDepth = null): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_plain($value, $maxDepth)->isOk();
	}


	public function is_list($value, ?int $plainMaxDepth = null): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_list($value, $plainMaxDepth)->isOk();
	}


	public function is_list_sorted($value, ?int $plainMaxDepth = null): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_list_sorted($value, $plainMaxDepth)->isOk();
	}


	public function is_dict($value, ?int $plainMaxDepth = null): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_dict($value, $plainMaxDepth)->isOk();
	}


	public function is_dict_sorted($value, ?int $plainMaxDepth = null, $fnSortCmp = null): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_dict_sorted($value, $plainMaxDepth, $fnSortCmp)->isOk();
	}


	public function is_table($value): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_table($value)->isOk();
	}


	public function is_matrix($value): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_matrix($value)->isOk();
	}


	public function is_matrix_strict($value): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_matrix_strict($value)->isOk();
	}


	public function is_arrpath($path, ?string $dot = null): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_arrpath($path, $dot)->isOk();
	}


	public function is_array_of_type($value, string $type): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_of_type($value, $type)->isOk();
	}


	public function is_array_of_resource_type($value, string $resourceType): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_of_resource_type($value, $resourceType)->isOk();
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 */
	public function is_array_of_a($value, string $className): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_of_a($value, $className)->isOk();
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 */
	public function is_array_of_class($value, string $className): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_of_class($value, $className)->isOk();
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 */
	public function is_array_of_subclass($value, string $className): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_of_subclass($value, $className)->isOk();
	}


	/**
	 * @param callable $fn
	 *
	 * @noinspection PhpDocSignatureIsNotCompleteInspection
	 */
	public function is_array_of_callback($value, callable $fn, array $args = []): bool
	{
		return \Gzhegow\Lib\Lib::$arr->type_array_of_callback($value, $fn, $args)->isOk();
	}


	public function is_fileline($value): bool
	{
		return \Gzhegow\Lib\Lib::$debug->type_fileline($value)->isOk();
	}


	public function is_html_tag($value): bool
	{
		return \Gzhegow\Lib\Lib::$format->type_html_tag($value)->isOk();
	}


	public function is_xml_tag($value): bool
	{
		return \Gzhegow\Lib\Lib::$format->type_xml_tag($value)->isOk();
	}


	public function is_xml_nstag($value): bool
	{
		return \Gzhegow\Lib\Lib::$format->type_xml_nstag($value)->isOk();
	}


	public function is_regex($value): bool
	{
		return \Gzhegow\Lib\Lib::$preg->type_regex($value)->isOk();
	}


	public function is_regexp($value): bool
	{
		return \Gzhegow\Lib\Lib::$preg->type_regexp($value)->isOk();
	}


	public function is_address_ip($value): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_address_ip($value)->isOk();
	}


	public function is_address_ip_v4($value): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_address_ip_v4($value)->isOk();
	}


	public function is_address_ip_v6($value): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_address_ip_v6($value)->isOk();
	}


	public function is_address_mac($value): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_address_mac($value)->isOk();
	}


	public function is_subnet($value, ?string $ipFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_subnet($value, $ipFallback)->isOk();
	}


	public function is_subnet_v4($value, ?string $ipFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_subnet_v4($value, $ipFallback)->isOk();
	}


	public function is_subnet_v6($value, ?string $ipFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$net->type_subnet_v6($value, $ipFallback)->isOk();
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function is_url(
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		return \Gzhegow\Lib\Lib::$url->type_url($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs)->isOk();
	}


	/**
	 * @param string|true $value
	 */
	public function is_host($value, ?int $isHostIdnaAscii = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$url->type_host($value, $isHostIdnaAscii, $refs)->isOk();
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function is_link($value, $query = null, $fragment = null, ?int $isLinkUrlencoded = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$url->type_link($value, $query, $fragment, $isLinkUrlencoded, $refs)->isOk();
	}


	public function is_uuid($value): bool
	{
		return \Gzhegow\Lib\Lib::$random->type_uuid($value)->isOk();
	}


	public function is_countable($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_countable($value)->isOk();
	}


	public function is_countable_object($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_countable_object($value)->isOk();
	}


	public function is_sizeable($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_sizeable($value)->isOk();
	}


	public function is_timezone($timezone, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_timezone($timezone, $allowedTimezoneTypes)->isOk();
	}


	public function is_timezone_offset($timezoneOrOffset): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_timezone_offset($timezoneOrOffset)->isOk();
	}


	public function is_timezone_abbr($timezoneOrAbbr): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_timezone_abbr($timezoneOrAbbr)->isOk();
	}


	public function is_timezone_name($timezoneOrName): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_timezone_name($timezoneOrName)->isOk();
	}


	public function is_timezone_nameabbr($timezoneOrNameOrAbbr): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_timezone_nameabbr($timezoneOrNameOrAbbr)->isOk();
	}


	public function is_date($datestring, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_date($datestring, $timezoneFallback)->isOk();
	}


	public function is_adate($datestring, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_adate($datestring, $timezoneFallback)->isOk();
	}


	public function is_idate($datestring, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_idate($datestring, $timezoneFallback)->isOk();
	}


	public function is_date_formatted($dateFormatted, $formats, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_date_formatted($dateFormatted, $formats, $timezoneFallback)->isOk();
	}


	public function is_adate_formatted($dateFormatted, $formats, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_adate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk();
	}


	public function is_idate_formatted($dateFormatted, $formats, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_idate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk();
	}


	public function is_date_tz($datestring, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_date_tz($datestring, $allowedTimezoneTypes)->isOk();
	}


	public function is_adate_tz($datestring, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_adate_tz($datestring, $allowedTimezoneTypes)->isOk();
	}


	public function is_idate_tz($datestring, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_idate_tz($datestring, $allowedTimezoneTypes)->isOk();
	}


	public function is_date_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_date_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk();
	}


	public function is_adate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_adate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk();
	}


	public function is_idate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_idate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk();
	}


	public function is_date_microtime($microtime, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_date_microtime($microtime, $timezoneFallback)->isOk();
	}


	public function is_adate_microtime($microtime, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_adate_microtime($microtime, $timezoneFallback)->isOk();
	}


	public function is_idate_microtime($microtime, $timezoneFallback = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_idate_microtime($microtime, $timezoneFallback)->isOk();
	}


	public function is_interval($interval): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_interval($interval)->isOk();
	}


	public function is_interval_duration($duration): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_interval_duration($duration)->isOk();
	}


	public function is_interval_datestring($datestring): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_interval_datestring($datestring)->isOk();
	}


	public function is_interval_microtime($microtime): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_interval_microtime($microtime)->isOk();
	}


	public function is_interval_ago($date, ?\DateTimeInterface $from = null, ?bool $reverse = null): bool
	{
		return \Gzhegow\Lib\Lib::$date->type_interval_ago($date, $from, $reverse)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_exists($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_exists($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_class($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_class($value, $flags)->isOk();
	}


	public function is_struct_interface($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_interface($value, $flags)->isOk();
	}


	public function is_struct_trait($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_trait($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_enum($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_enum($value, $flags)->isOk();
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function is_struct_fqcn($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_fqcn($value, $flags)->isOk();
	}


	public function is_struct_namespace($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_namespace($value, $flags)->isOk();
	}


	public function is_struct_basename($value, ?int $flags = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_struct_basename($value, $flags)->isOk();
	}


	public function is_resource($value, ?string $resourceType = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_resource($value, $resourceType)->isOk();
	}


	public function is_resource_opened($value, ?string $resourceType = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_resource_opened($value, $resourceType)->isOk();
	}


	public function is_resource_closed($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_resource_closed($value)->isOk();
	}


	public function is_any_not_resource($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_any_not_resource($value)->isOk();
	}


	public function is_curl($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_curl($value)->isOk();
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 */
	public function is_enum_case($value, ?string $enumClass = null): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_enum_case($value, $enumClass)->isOk();
	}


	public function is_method_array($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_method_array($value)->isOk();
	}


	public function is_method_string($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_method_string($value, $refs)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_object($value, $newScope)->isOk();
	}


	public function is_callable_object($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_object($value, $newScope)->isOk();
	}


	public function is_callable_object_closure($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_object_closure($value, $newScope)->isOk();
	}


	public function is_callable_object_invokable($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_object_invokable($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_array($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array_method($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_array_method($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array_method_static($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_array_method_static($value, $newScope)->isOk();
	}


	/**
	 * @param string|object $newScope
	 */
	public function is_callable_array_method_non_static($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_array_method_non_static($value, $newScope)->isOk();
	}


	public function is_callable_string($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_string($value, $newScope)->isOk();
	}


	public function is_callable_string_function($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_string_function($value)->isOk();
	}


	public function is_callable_string_function_internal($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_string_function_internal($value)->isOk();
	}


	public function is_callable_string_function_non_internal($value): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_string_function_non_internal($value)->isOk();
	}


	public function is_callable_string_method_static($value, $newScope = 'static'): bool
	{
		return \Gzhegow\Lib\Lib::$php->type_callable_string_method_static($value, $newScope)->isOk();
	}


	public function is_chmod($value): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_chmod($value)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_path($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_path($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_realpath($value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_realpath($value, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_freepath($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_freepath($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_dirpath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_dirpath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_filepath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_filepath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_dirpath_realpath($value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_dirpath_realpath($value, $isAllowSymlink, $refs)->isOk();
	}


	/**
	 * @param array{ 0: array|null } $refs
	 */
	public function is_filepath_realpath($value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_filepath_realpath($value, $isAllowSymlink, $refs)->isOk();
	}


	public function is_filename($value): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_filename($value)->isOk();
	}


	public function is_file($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_file($value, $extensions, $mimeTypes, $filters)->isOk();
	}


	public function is_image($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_image($value, $extensions, $mimeTypes, $filters)->isOk();
	}


	public function is_socket($value): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_socket($value)->isOk();
	}


	public function is_stream($value): bool
	{
		return \Gzhegow\Lib\Lib::$fs->type_stream($value)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_email($value, ?array $filters = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_email($value, $filters, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_email_fake($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_email_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_email_non_fake($value, ?array $filters = null, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_email_non_fake($value, $filters, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_phone($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_phone($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_phone_fake($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_phone_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_phone_non_fake($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_phone_non_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string, 3?: string } $refs
	 */
	public function is_phone_real($value, ?string $region = '', array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_phone_real($value, $region, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_tel($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_tel($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function is_tel_fake($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_tel_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_tel_non_fake($value, array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_tel_non_fake($value, $refs)->isOk();
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function is_tel_real($value, ?string $region = '', array $refs = []): bool
	{
		return \Gzhegow\Lib\Lib::$social->type_tel_real($value, $region, $refs)->isOk();
	}


	/**
	 * @return mixed
	 */
	public function assert_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `empty` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 *
	 * @return string|array|\Countable|null
	 */
	public function assert_blank($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_blank($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `blank` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_blank($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_blank($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_blank` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 *
	 * @return mixed
	 */
	public function assert_nullable($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_nullable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `nullable` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_nullable($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_nullable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_nullable` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 *
	 * @return mixed
	 */
	public function assert_passed($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_passed($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `passed` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_passed($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_passed($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_passed` is failed', [ $value ] ]);
	}


	/**
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 *
	 * @return string|Nil
	 */
	public function assert_nil($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_nil($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `nil` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_nil($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_nil($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_nil` is failed', [ $value ] ]);
	}


	/**
	 * @return null
	 */
	public function assert_null($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_null($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `null` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_null($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_null($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_null` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_false($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_false($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `false` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_false($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_false($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_false` is failed', [ $value ] ]);
	}


	/**
	 * @return true
	 */
	public function assert_true($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_true($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `true` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_true($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_true($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_true` is failed', [ $value ] ]);
	}


	/**
	 * @return bool
	 */
	public function assert_bool($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_bool($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `bool` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_boolfalse($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_boolfalse($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `boolfalse` is failed', [ $value ] ]);
	}


	/**
	 * @return true
	 */
	public function assert_booltrue($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_booltrue($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `booltrue` is failed', [ $value ] ]);
	}


	/**
	 * @return bool
	 */
	public function assert_userbool($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_userbool($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `userbool` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_userfalse($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_userfalse($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `userfalse` is failed', [ $value ] ]);
	}


	/**
	 * @return false
	 */
	public function assert_usertrue($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_usertrue($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `usertrue` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_array($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_array_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_not_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_array_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_array_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_array_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_array_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_array($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_array($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_array` is failed', [ $value ] ]);
	}


	/**
	 * @return object
	 */
	public function assert_object($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_object($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `object` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_object($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_object($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_object` is failed', [ $value ] ]);
	}


	/**
	 * @return \stdClass
	 */
	public function assert_stdclass($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_stdclass($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `stdclass` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_stdclass($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_stdclass($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_stdclass` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_nan($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_nan($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `nan` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_nan($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_not_nan($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_nan` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_nan($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_any_not_nan($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_nan` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_finite($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_finite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `finite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_finite($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_not_finite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_finite` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_finite($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_any_not_finite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_finite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_infinite($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_infinite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `infinite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_infinite($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_not_infinite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_infinite` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_infinite($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_any_not_infinite($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_infinite` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_min($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_min($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_min` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_not_float_min($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_not_float_min($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_not_float_min` is failed', [ $value ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_any_not_float_min($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_any_not_float_min($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_float_min` is failed', [ $value ] ]);
	}


	/**
	 * @return Number
	 */
	public function assert_number($value, ?bool $allowExp = null)
	{
		if (\Gzhegow\Lib\Lib::$num->type_number($value, $allowExp)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `number` is failed', [ $value, $allowExp ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_non_zero($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_non_zero($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_non_zero` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_non_negative($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_non_negative($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_non_negative` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_non_positive($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_non_positive($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_non_positive` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_negative($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_negative($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_negative` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_positive($value, ?bool $isAllowExp = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_positive($value, $isAllowExp, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_positive` is failed', [ $value, $isAllowExp, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_zero($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_non_zero($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_zero` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_negative($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_non_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_positive($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_non_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_negative($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_positive($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_positive_or_minus_one($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_positive_or_minus_one($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_positive_or_minus_one` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_int_non_negative_or_minus_one($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_int_non_negative_or_minus_one($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_int_non_negative_or_minus_one` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_float($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_non_zero($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_float_non_zero($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_non_zero` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_non_negative($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_float_non_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_non_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_non_positive($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_float_non_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_non_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_negative($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_float_negative($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_negative` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_float_positive($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_numeric_float_positive($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_float_positive` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$num->type_numeric_trimpad($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_non_zero(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_zero($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_non_zero` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_non_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_non_negative` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_non_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_non_positive` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_negative(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$num->type_numeric_trimpad_negative($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_negative` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_numeric_trimpad_positive(
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$num->type_numeric_trimpad_positive($value, $lenTrim, $lenPad, $stringPad, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `numeric_trimpad_positive` is failed', [ $value, $lenTrim, $lenPad, $stringPad, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal($value, int $scale = 0, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_decimal($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_non_zero($value, int $scale = 0, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_decimal_non_zero($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_non_zero` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_non_negative($value, int $scale = 0, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_decimal_non_negative($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_non_negative` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_non_positive($value, int $scale = 0, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_decimal_non_positive($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_non_positive` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_negative($value, int $scale = 0, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_decimal_negative($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_negative` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_decimal_positive($value, int $scale = 0, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$num->type_decimal_positive($value, $scale, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `decimal_positive` is failed', [ $value, $scale, $refs ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_num($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_non_zero($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_num_non_zero($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_non_zero` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_non_negative($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_num_non_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_non_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_non_positive($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_num_non_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_non_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_negative($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_num_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int|float
	 */
	public function assert_num_positive($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_num_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `num_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_zero($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_non_zero($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_zero` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_negative($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_non_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_positive($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_non_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_negative($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_positive($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_positive_or_minus_one($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_positive_or_minus_one($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_positive_or_minus_one` is failed', [ $value ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_int_non_negative_or_minus_one($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_int_non_negative_or_minus_one($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `int_non_negative_or_minus_one` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_non_zero($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_non_zero($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_non_zero` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_non_negative($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_non_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_non_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_non_positive($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_non_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_non_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_negative($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_negative($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_negative` is failed', [ $value ] ]);
	}


	/**
	 * @return float
	 */
	public function assert_float_positive($value)
	{
		if (\Gzhegow\Lib\Lib::$num->type_float_positive($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `float_positive` is failed', [ $value ] ]);
	}


	/**
	 * @return Bcnumber
	 */
	public function assert_bcnumber($value)
	{
		if (\Gzhegow\Lib\Lib::$bcmath->type_bcnumber($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `bcnumber` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_string($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_a_string($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_string` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_string_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_a_string_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_string_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_string_not_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_a_string_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_string_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_a_trim($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_a_trim($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `a_trim` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_string($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_string($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `string` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_string_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_string_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `string_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_string_not_empty($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_string_not_empty($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `string_not_empty` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_trim($value, ?string $characters = null)
	{
		if (\Gzhegow\Lib\Lib::$str->type_trim($value, $characters)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `trim` is failed', [ $value, $characters ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_char($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_char($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `char` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_letter($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_letter($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `letter` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_word($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_word($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `word` is failed', [ $value ] ]);
	}


	/**
	 * @return Alphabet
	 */
	public function assert_alphabet($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_alphabet($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `alphabet` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_ctype_digit($value)
	{
		if (\Gzhegow\Lib\Lib::$str->type_ctype_digit($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `ctype_digit` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_ctype_alpha($value, ?bool $allowUpperCase = null)
	{
		if (\Gzhegow\Lib\Lib::$str->type_ctype_alpha($value, $allowUpperCase)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `ctype_alpha` is failed', [ $value, $allowUpperCase ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_ctype_alnum($value, ?bool $allowUpperCase = null)
	{
		if (\Gzhegow\Lib\Lib::$str->type_ctype_alnum($value, $allowUpperCase)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `ctype_alnum` is failed', [ $value, $allowUpperCase ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base($value, $alphabet)
	{
		if (\Gzhegow\Lib\Lib::$crypt->type_base($value, $alphabet)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base` is failed', [ $value, $alphabet ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_bin($value)
	{
		if (\Gzhegow\Lib\Lib::$crypt->type_base_bin($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_bin` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_oct($value)
	{
		if (\Gzhegow\Lib\Lib::$crypt->type_base_oct($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_oct` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_dec($value)
	{
		if (\Gzhegow\Lib\Lib::$crypt->type_base_dec($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_dec` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_base_hex($value)
	{
		if (\Gzhegow\Lib\Lib::$crypt->type_base_hex($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `base_hex` is failed', [ $value ] ]);
	}


	/**
	 * @return int|string
	 */
	public function assert_key($key)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_key($key)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `key` is failed', [ $key ] ]);
	}


	/**
	 * @return mixed
	 */
	public function assert_key_exists($key, array $array)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_key_exists($key, $array)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `key_exists` is failed', [ $key, $array ] ]);
	}


	/**
	 * @return true
	 */
	public function assert_key_not_exists($key, array $array)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_key_not_exists($key, $array)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `key_not_exists` is failed', [ $key, $array ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_plain($value, ?int $maxDepth = null)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_plain($value, $maxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_plain` is failed', [ $value, $maxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_list($value, ?int $plainMaxDepth = null)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_list($value, $plainMaxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `list` is failed', [ $value, $plainMaxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_list_sorted($value, ?int $plainMaxDepth = null)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_list_sorted($value, $plainMaxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `list_sorted` is failed', [ $value, $plainMaxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_dict($value, ?int $plainMaxDepth = null)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_dict($value, $plainMaxDepth)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dict` is failed', [ $value, $plainMaxDepth ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_dict_sorted($value, ?int $plainMaxDepth = null, $fnSortCmp = null)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_dict_sorted($value, $plainMaxDepth, $fnSortCmp)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dict_sorted` is failed', [ $value, $plainMaxDepth, $fnSortCmp ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_table($value)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_table($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `table` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_matrix($value)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_matrix($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `matrix` is failed', [ $value ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_matrix_strict($value)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_matrix_strict($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `matrix_strict` is failed', [ $value ] ]);
	}


	/**
	 * @return ArrPath
	 */
	public function assert_arrpath($path, ?string $dot = null)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_arrpath($path, $dot)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `arrpath` is failed', [ $path, $dot ] ]);
	}


	/**
	 * @return array
	 */
	public function assert_array_of_type($value, string $type)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_of_type($value, $type)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_type` is failed', [ $value, $type ] ]);
	}


	/**
	 * @return resource[]
	 */
	public function assert_array_of_resource_type($value, string $resourceType)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_of_resource_type($value, $resourceType)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_resource_type` is failed', [ $value, $resourceType ] ]);
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 *
	 * @return T[]
	 */
	public function assert_array_of_a($value, string $className)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_of_a($value, $className)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_a` is failed', [ $value, $className ] ]);
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 *
	 * @return T[]
	 */
	public function assert_array_of_class($value, string $className)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_of_class($value, $className)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_class` is failed', [ $value, $className ] ]);
	}


	/**
	 * @template T
	 * @param class-string<T> $className
	 *
	 * @return T[]
	 */
	public function assert_array_of_subclass($value, string $className)
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_of_subclass($value, $className)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_subclass` is failed', [ $value, $className ] ]);
	}


	/**
	 * @param callable $fn
	 *
	 * @noinspection PhpDocSignatureIsNotCompleteInspection
	 *
	 * @return array
	 */
	public function assert_array_of_callback($value, callable $fn, array $args = [])
	{
		if (\Gzhegow\Lib\Lib::$arr->type_array_of_callback($value, $fn, $args)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `array_of_callback` is failed', [ $value, $fn, $args ] ]);
	}


	/**
	 * @return array{ 0: string, 1: int }
	 */
	public function assert_fileline($value)
	{
		if (\Gzhegow\Lib\Lib::$debug->type_fileline($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `fileline` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_html_tag($value)
	{
		if (\Gzhegow\Lib\Lib::$format->type_html_tag($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `html_tag` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_xml_tag($value)
	{
		if (\Gzhegow\Lib\Lib::$format->type_xml_tag($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `xml_tag` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_xml_nstag($value)
	{
		if (\Gzhegow\Lib\Lib::$format->type_xml_nstag($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `xml_nstag` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_regex($value)
	{
		if (\Gzhegow\Lib\Lib::$preg->type_regex($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `regex` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_regexp($value)
	{
		if (\Gzhegow\Lib\Lib::$preg->type_regexp($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `regexp` is failed', [ $value ] ]);
	}


	/**
	 * @return AddressIpV4|AddressIpV6
	 */
	public function assert_address_ip($value)
	{
		if (\Gzhegow\Lib\Lib::$net->type_address_ip($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_ip` is failed', [ $value ] ]);
	}


	/**
	 * @return AddressIpV4
	 */
	public function assert_address_ip_v4($value)
	{
		if (\Gzhegow\Lib\Lib::$net->type_address_ip_v4($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_ip_v4` is failed', [ $value ] ]);
	}


	/**
	 * @return AddressIpV6
	 */
	public function assert_address_ip_v6($value)
	{
		if (\Gzhegow\Lib\Lib::$net->type_address_ip_v6($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_ip_v6` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_address_mac($value)
	{
		if (\Gzhegow\Lib\Lib::$net->type_address_mac($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `address_mac` is failed', [ $value ] ]);
	}


	/**
	 * @return SubnetV4|SubnetV6
	 */
	public function assert_subnet($value, ?string $ipFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$net->type_subnet($value, $ipFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `subnet` is failed', [ $value, $ipFallback ] ]);
	}


	/**
	 * @return SubnetV4
	 */
	public function assert_subnet_v4($value, ?string $ipFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$net->type_subnet_v4($value, $ipFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `subnet_v4` is failed', [ $value, $ipFallback ] ]);
	}


	/**
	 * @return SubnetV6
	 */
	public function assert_subnet_v6($value, ?string $ipFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$net->type_subnet_v6($value, $ipFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `subnet_v6` is failed', [ $value, $ipFallback ] ]);
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 *
	 * @return string
	 */
	public function assert_url(
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	) {
		if (\Gzhegow\Lib\Lib::$url->type_url($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `url` is failed', [ $value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs ] ]);
	}


	/**
	 * @param string|true $value
	 *
	 * @return string
	 */
	public function assert_host($value, ?int $isHostIdnaAscii = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$url->type_host($value, $isHostIdnaAscii, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `host` is failed', [ $value, $isHostIdnaAscii, $refs ] ]);
	}


	/**
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 *
	 * @return string
	 */
	public function assert_link($value, $query = null, $fragment = null, ?int $isLinkUrlencoded = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$url->type_link($value, $query, $fragment, $isLinkUrlencoded, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `link` is failed', [ $value, $query, $fragment, $isLinkUrlencoded, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_uuid($value)
	{
		if (\Gzhegow\Lib\Lib::$random->type_uuid($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `uuid` is failed', [ $value ] ]);
	}


	/**
	 * @return array|\Countable
	 */
	public function assert_countable($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_countable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `countable` is failed', [ $value ] ]);
	}


	/**
	 * @return \Countable
	 */
	public function assert_countable_object($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_countable_object($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `countable_object` is failed', [ $value ] ]);
	}


	/**
	 * @return string|array|\Countable
	 */
	public function assert_sizeable($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_sizeable($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `sizeable` is failed', [ $value ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone($timezone, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_timezone($timezone, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone` is failed', [ $timezone, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_offset($timezoneOrOffset)
	{
		if (\Gzhegow\Lib\Lib::$date->type_timezone_offset($timezoneOrOffset)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_offset` is failed', [ $timezoneOrOffset ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_abbr($timezoneOrAbbr)
	{
		if (\Gzhegow\Lib\Lib::$date->type_timezone_abbr($timezoneOrAbbr)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_abbr` is failed', [ $timezoneOrAbbr ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_name($timezoneOrName)
	{
		if (\Gzhegow\Lib\Lib::$date->type_timezone_name($timezoneOrName)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_name` is failed', [ $timezoneOrName ] ]);
	}


	/**
	 * @return \DateTimeZone
	 */
	public function assert_timezone_nameabbr($timezoneOrNameOrAbbr)
	{
		if (\Gzhegow\Lib\Lib::$date->type_timezone_nameabbr($timezoneOrNameOrAbbr)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `timezone_nameabbr` is failed', [ $timezoneOrNameOrAbbr ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date($datestring, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_date($datestring, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date` is failed', [ $datestring, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate($datestring, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_adate($datestring, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate` is failed', [ $datestring, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate($datestring, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_idate($datestring, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate` is failed', [ $datestring, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_formatted($dateFormatted, $formats, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_date_formatted($dateFormatted, $formats, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_formatted` is failed', [ $dateFormatted, $formats, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_formatted($dateFormatted, $formats, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_adate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_formatted` is failed', [ $dateFormatted, $formats, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_formatted($dateFormatted, $formats, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_idate_formatted($dateFormatted, $formats, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_formatted` is failed', [ $dateFormatted, $formats, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_tz($datestring, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_date_tz($datestring, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_tz` is failed', [ $datestring, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_tz($datestring, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_adate_tz($datestring, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_tz` is failed', [ $datestring, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_tz($datestring, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_idate_tz($datestring, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_tz` is failed', [ $datestring, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_date_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_tz_formatted` is failed', [ $dateFormatted, $formats, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_adate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_tz_formatted` is failed', [ $dateFormatted, $formats, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_tz_formatted($dateFormatted, $formats, ?array $allowedTimezoneTypes = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_idate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_tz_formatted` is failed', [ $dateFormatted, $formats, $allowedTimezoneTypes ] ]);
	}


	/**
	 * @return \DateTimeInterface
	 */
	public function assert_date_microtime($microtime, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_date_microtime($microtime, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `date_microtime` is failed', [ $microtime, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTime
	 */
	public function assert_adate_microtime($microtime, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_adate_microtime($microtime, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `adate_microtime` is failed', [ $microtime, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateTimeImmutable
	 */
	public function assert_idate_microtime($microtime, $timezoneFallback = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_idate_microtime($microtime, $timezoneFallback)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `idate_microtime` is failed', [ $microtime, $timezoneFallback ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval($interval)
	{
		if (\Gzhegow\Lib\Lib::$date->type_interval($interval)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval` is failed', [ $interval ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_duration($duration)
	{
		if (\Gzhegow\Lib\Lib::$date->type_interval_duration($duration)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_duration` is failed', [ $duration ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_datestring($datestring)
	{
		if (\Gzhegow\Lib\Lib::$date->type_interval_datestring($datestring)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_datestring` is failed', [ $datestring ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_microtime($microtime)
	{
		if (\Gzhegow\Lib\Lib::$date->type_interval_microtime($microtime)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_microtime` is failed', [ $microtime ] ]);
	}


	/**
	 * @return \DateInterval
	 */
	public function assert_interval_ago($date, ?\DateTimeInterface $from = null, ?bool $reverse = null)
	{
		if (\Gzhegow\Lib\Lib::$date->type_interval_ago($date, $from, $reverse)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `interval_ago` is failed', [ $date, $from, $reverse ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T
	 */
	public function assert_struct_exists($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_exists($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_exists` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T
	 */
	public function assert_struct($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T
	 */
	public function assert_struct_class($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_class($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_class` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return class-string
	 */
	public function assert_struct_interface($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_interface($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_interface` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return class-string
	 */
	public function assert_struct_trait($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_trait($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_trait` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T
	 */
	public function assert_struct_enum($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_enum($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_enum` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 *
	 * @return class-string<T
	 */
	public function assert_struct_fqcn($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_fqcn($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_fqcn` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_struct_namespace($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_namespace($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_namespace` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_struct_basename($value, ?int $flags = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_struct_basename($value, $flags)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `struct_basename` is failed', [ $value, $flags ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_resource($value, ?string $resourceType = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_resource($value, $resourceType)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `resource` is failed', [ $value, $resourceType ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_resource_opened($value, ?string $resourceType = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_resource_opened($value, $resourceType)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `resource_opened` is failed', [ $value, $resourceType ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_resource_closed($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_resource_closed($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `resource_closed` is failed', [ $value ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_any_not_resource($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_any_not_resource($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `any_not_resource` is failed', [ $value ] ]);
	}


	/**
	 * @return resource|\CurlHandle
	 */
	public function assert_curl($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_curl($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `curl` is failed', [ $value ] ]);
	}


	/**
	 * @template-covariant T of \UnitEnum
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 *
	 * @return T
	 */
	public function assert_enum_case($value, ?string $enumClass = null)
	{
		if (\Gzhegow\Lib\Lib::$php->type_enum_case($value, $enumClass)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `enum_case` is failed', [ $value, $enumClass ] ]);
	}


	/**
	 * @return array{ 0: class-string, 1: string }
	 */
	public function assert_method_array($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_method_array($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `method_array` is failed', [ $value ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_method_string($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$php->type_method_string($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `method_string` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable
	 */
	public function assert_callable($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_object($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable|\Closure|object
	 */
	public function assert_callable_object($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_object($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_object` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return \Closure
	 */
	public function assert_callable_object_closure($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_object_closure($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_object_closure` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable|object
	 */
	public function assert_callable_object_invokable($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_object_invokable($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_object_invokable` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: object|class-string, 1: string }
	 */
	public function assert_callable_array($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_array($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: object|class-string, 1: string }
	 */
	public function assert_callable_array_method($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_array_method($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array_method` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: class-string, 1: string }
	 */
	public function assert_callable_array_method_static($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_array_method_static($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array_method_static` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @param string|object $newScope
	 *
	 * @return callable|array{ 0: object, 1: string }
	 */
	public function assert_callable_array_method_non_static($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_array_method_non_static($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_array_method_non_static` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable-string
	 */
	public function assert_callable_string($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_string($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return callable-string
	 */
	public function assert_callable_string_function($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_string_function($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_function` is failed', [ $value ] ]);
	}


	/**
	 * @return callable-string
	 */
	public function assert_callable_string_function_internal($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_string_function_internal($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_function_internal` is failed', [ $value ] ]);
	}


	/**
	 * @return callable-string
	 */
	public function assert_callable_string_function_non_internal($value)
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_string_function_non_internal($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_function_non_internal` is failed', [ $value ] ]);
	}


	/**
	 * @return callable-string
	 */
	public function assert_callable_string_method_static($value, $newScope = 'static')
	{
		if (\Gzhegow\Lib\Lib::$php->type_callable_string_method_static($value, $newScope)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `callable_string_method_static` is failed', [ $value, $newScope ] ]);
	}


	/**
	 * @return int
	 */
	public function assert_chmod($value)
	{
		if (\Gzhegow\Lib\Lib::$fs->type_chmod($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `chmod` is failed', [ $value ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_path($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_path($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `path` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_realpath($value, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_realpath($value, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `realpath` is failed', [ $value, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_freepath($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_freepath($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `freepath` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_dirpath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_dirpath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dirpath` is failed', [ $value, $isAllowExists, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_filepath($value, ?bool $isAllowExists, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_filepath($value, $isAllowExists, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `filepath` is failed', [ $value, $isAllowExists, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_dirpath_realpath($value, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_dirpath_realpath($value, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `dirpath_realpath` is failed', [ $value, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @param array{ 0: array|null } $refs
	 *
	 * @return string
	 */
	public function assert_filepath_realpath($value, ?bool $isAllowSymlink = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$fs->type_filepath_realpath($value, $isAllowSymlink, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `filepath_realpath` is failed', [ $value, $isAllowSymlink, $refs ] ]);
	}


	/**
	 * @return string
	 */
	public function assert_filename($value)
	{
		if (\Gzhegow\Lib\Lib::$fs->type_filename($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `filename` is failed', [ $value ] ]);
	}


	/**
	 * @return \SplFileInfo
	 */
	public function assert_file($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null)
	{
		if (\Gzhegow\Lib\Lib::$fs->type_file($value, $extensions, $mimeTypes, $filters)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `file` is failed', [ $value, $extensions, $mimeTypes, $filters ] ]);
	}


	/**
	 * @return \SplFileInfo
	 */
	public function assert_image($value, ?array $extensions = null, ?array $mimeTypes = null, ?array $filters = null)
	{
		if (\Gzhegow\Lib\Lib::$fs->type_image($value, $extensions, $mimeTypes, $filters)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `image` is failed', [ $value, $extensions, $mimeTypes, $filters ] ]);
	}


	/**
	 * @return resource|\Socket
	 */
	public function assert_socket($value)
	{
		if (\Gzhegow\Lib\Lib::$fs->type_socket($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `socket` is failed', [ $value ] ]);
	}


	/**
	 * @return resource
	 */
	public function assert_stream($value)
	{
		if (\Gzhegow\Lib\Lib::$fs->type_stream($value)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `stream` is failed', [ $value ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_email($value, ?array $filters = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_email($value, $filters, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `email` is failed', [ $value, $filters, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_email_fake($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_email_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `email_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_email_non_fake($value, ?array $filters = null, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_email_non_fake($value, $filters, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `email_non_fake` is failed', [ $value, $filters, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_phone($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone_fake($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_phone_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone_non_fake($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_phone_non_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone_non_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string, 3?: string } $refs
	 *
	 * @return string
	 */
	public function assert_phone_real($value, ?string $region = '', array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_phone_real($value, $region, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `phone_real` is failed', [ $value, $region, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_tel($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel_fake($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_tel_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel_non_fake($value, array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_tel_non_fake($value, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel_non_fake` is failed', [ $value, $refs ] ]);
	}


	/**
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 *
	 * @return string
	 */
	public function assert_tel_real($value, ?string $region = '', array $refs = [])
	{
		if (\Gzhegow\Lib\Lib::$social->type_tel_real($value, $region, $refs)->isOk([ &$ref ])) return $ref;

		$t = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
		$t = [ $t['file'] ?? '{{file}}', $t['line'] ?? -1 ];

		throw new LogicException($t, [ 'Assert `tel_real` is failed', [ $value, $region, $refs ] ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string|array|\Countable|null, 1?: Ret<string|array|\Countable|null> } $r
	 *
	 * > Специальный тип, который значит, что значение можно отбросить или не учитывать, т.к. оно не несёт информации
	 */
	public function filter_blank(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_blank($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_blank(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_blank($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 *
	 * > Специальный тип, который значит, что значение можно заменить NULL-ом
	 */
	public function filter_nullable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_nullable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_nullable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_nullable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 *
	 * > Специальный тип, который значит, что значение было отправлено пользователем, а не появилось из PHP
	 */
	public function filter_passed(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_passed($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_passed(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_passed($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string|Nil, 1?: Ret<string|Nil> } $r
	 *
	 * > Специальный тип-синоним NULL, переданный пользователем через API, например '{N}'
	 * > в случаях, когда NULL интерпретируется как "не трогать", а NIL как "очистить"
	 * > NAN не равен ничему даже самому себе
	 * > NIL равен только самому себе
	 * > NULL означает пустоту и им можно заменить значения '', [], `resource (closed)`, NIL, но нельзя заменить NAN
	 */
	public function filter_nil(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_nil($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_nil(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_nil($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: null, 1?: Ret<null> } $r
	 */
	public function filter_null(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_null($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_null(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_null($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_false(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_false($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_false(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_false($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: true, 1?: Ret<true> } $r
	 */
	public function filter_true(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_true($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_true(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_true($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: bool, 1?: Ret<bool> } $r
	 */
	public function filter_bool(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_bool($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_boolfalse(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_boolfalse($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: true, 1?: Ret<true> } $r
	 */
	public function filter_booltrue(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_booltrue($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: bool, 1?: Ret<bool> } $r
	 */
	public function filter_userbool(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_userbool($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_userfalse(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_userfalse($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: false, 1?: Ret<false> } $r
	 */
	public function filter_usertrue(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_usertrue($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_array($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_array_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_array_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_array_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_array_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_array(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_array($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: object, 1?: Ret<object> } $r
	 */
	public function filter_object(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_object($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_object(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_object($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \stdClass, 1?: Ret<\stdClass> } $r
	 */
	public function filter_stdclass(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_stdclass($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_stdclass(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_stdclass($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_nan(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_nan($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_nan(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_not_nan($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_nan(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_any_not_nan($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_finite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_finite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_finite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_not_finite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_finite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_any_not_finite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_infinite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_infinite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_infinite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_not_infinite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_infinite(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_any_not_infinite($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_min(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_min($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_not_float_min(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_not_float_min($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_any_not_float_min(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_any_not_float_min($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: Number, 1?: Ret<Number> } $r
	 */
	public function filter_number(array $r, $value, ?bool $allowExp = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_number($value, $allowExp))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_non_zero(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_non_zero($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_non_negative(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_non_negative($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_non_positive(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_non_positive($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_negative(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_negative($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_positive(array $r, $value, ?bool $isAllowExp = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_positive($value, $isAllowExp, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_zero(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_non_zero($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_non_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_non_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_positive_or_minus_one(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_positive_or_minus_one($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_int_non_negative_or_minus_one(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_int_non_negative_or_minus_one($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_float($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_non_zero(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_float_non_zero($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_non_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_float_non_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_non_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_float_non_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_negative(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_float_negative($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_float_positive(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_float_positive($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_trimpad($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_non_zero(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_zero($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_non_negative(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_negative($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_non_positive(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_non_positive($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_negative(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_negative($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_numeric_trimpad_positive(
		array $r,
		$value,
		?int $lenTrim = null,
		?int $lenPad = null,
		string $stringPad = '0',
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_numeric_trimpad_positive($value, $lenTrim, $lenPad, $stringPad, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_decimal($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_non_zero(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_decimal_non_zero($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_non_negative(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_decimal_non_negative($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_non_positive(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_decimal_non_positive($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_negative(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_decimal_negative($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_decimal_positive(array $r, $value, int $scale = 0, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_decimal_positive($value, $scale, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_num($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_non_zero(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_num_non_zero($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_non_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_num_non_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_non_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_num_non_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_num_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|float, 1?: Ret<int|float> } $r
	 */
	public function filter_num_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_num_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_zero(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_non_zero($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_non_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_non_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_positive_or_minus_one(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_positive_or_minus_one($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_int_non_negative_or_minus_one(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_int_non_negative_or_minus_one($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_non_zero(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_non_zero($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_non_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_non_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_non_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_non_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_negative(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_negative($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: float, 1?: Ret<float> } $r
	 */
	public function filter_float_positive(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$num->type_float_positive($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: Bcnumber, 1?: Ret<Bcnumber> } $r
	 */
	public function filter_bcnumber(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$bcmath->type_bcnumber($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_string(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_a_string($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_string_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_a_string_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_string_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_a_string_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_a_trim(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_a_trim($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_string(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_string($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_string_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_string_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_string_not_empty(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_string_not_empty($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_trim(array $r, $value, ?string $characters = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_trim($value, $characters))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_char(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_char($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_letter(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_letter($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_word(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_word($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: Alphabet, 1?: Ret<Alphabet> } $r
	 */
	public function filter_alphabet(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_alphabet($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_ctype_digit(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_ctype_digit($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_ctype_alpha(array $r, $value, ?bool $allowUpperCase = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_ctype_alpha($value, $allowUpperCase))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_ctype_alnum(array $r, $value, ?bool $allowUpperCase = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$str->type_ctype_alnum($value, $allowUpperCase))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base(array $r, $value, $alphabet): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$crypt->type_base($value, $alphabet))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_bin(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$crypt->type_base_bin($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_oct(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$crypt->type_base_oct($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_dec(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$crypt->type_base_dec($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_base_hex(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$crypt->type_base_hex($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int|string, 1?: Ret<int|string> } $r
	 */
	public function filter_key(array $r, $key): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_key($key))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: mixed, 1?: Ret<mixed> } $r
	 */
	public function filter_key_exists(array $r, $key, array $array): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_key_exists($key, $array))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: true, 1?: Ret<true> } $r
	 */
	public function filter_key_not_exists(array $r, $key, array $array): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_key_not_exists($key, $array))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_plain(array $r, $value, ?int $maxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_plain($value, $maxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_list(array $r, $value, ?int $plainMaxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_list($value, $plainMaxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_list_sorted(array $r, $value, ?int $plainMaxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_list_sorted($value, $plainMaxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_dict(array $r, $value, ?int $plainMaxDepth = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_dict($value, $plainMaxDepth))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_dict_sorted(array $r, $value, ?int $plainMaxDepth = null, $fnSortCmp = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_dict_sorted($value, $plainMaxDepth, $fnSortCmp))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_table(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_table($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_matrix(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_matrix($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_matrix_strict(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_matrix_strict($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: ArrPath, 1?: Ret<ArrPath> } $r
	 */
	public function filter_arrpath(array $r, $path, ?string $dot = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_arrpath($path, $dot))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 */
	public function filter_array_of_type(array $r, $value, string $type): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_of_type($value, $type))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource[], 1?: Ret<resource[]> } $r
	 */
	public function filter_array_of_resource_type(array $r, $value, string $resourceType): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_of_resource_type($value, $resourceType))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T[], 1?: Ret<T[]> } $r
	 *
	 * @template T
	 * @param class-string<T> $className
	 */
	public function filter_array_of_a(array $r, $value, string $className): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_of_a($value, $className))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T[], 1?: Ret<T[]> } $r
	 *
	 * @template T
	 * @param class-string<T> $className
	 */
	public function filter_array_of_class(array $r, $value, string $className): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_of_class($value, $className))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T[], 1?: Ret<T[]> } $r
	 *
	 * @template T
	 * @param class-string<T> $className
	 */
	public function filter_array_of_subclass(array $r, $value, string $className): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_of_subclass($value, $className))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array, 1?: Ret<array> } $r
	 *
	 * @param callable $fn
	 *
	 * @noinspection PhpDocSignatureIsNotCompleteInspection
	 */
	public function filter_array_of_callback(array $r, $value, callable $fn, array $args = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$arr->type_array_of_callback($value, $fn, $args))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array{ 0: string, 1: int }, 1?: Ret<array{ 0: string, 1: int }> } $r
	 */
	public function filter_fileline(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$debug->type_fileline($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_html_tag(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$format->type_html_tag($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_xml_tag(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$format->type_xml_tag($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_xml_nstag(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$format->type_xml_nstag($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_regex(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$preg->type_regex($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_regexp(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$preg->type_regexp($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: AddressIpV4|AddressIpV6, 1?: Ret<AddressIpV4|AddressIpV6> } $r
	 */
	public function filter_address_ip(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_address_ip($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: AddressIpV4, 1?: Ret<AddressIpV4> } $r
	 */
	public function filter_address_ip_v4(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_address_ip_v4($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: AddressIpV6, 1?: Ret<AddressIpV6> } $r
	 */
	public function filter_address_ip_v6(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_address_ip_v6($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_address_mac(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_address_mac($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: SubnetV4|SubnetV6, 1?: Ret<SubnetV4|SubnetV6> } $r
	 */
	public function filter_subnet(array $r, $value, ?string $ipFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_subnet($value, $ipFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: SubnetV4, 1?: Ret<SubnetV4> } $r
	 */
	public function filter_subnet_v4(array $r, $value, ?string $ipFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_subnet_v4($value, $ipFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: SubnetV6, 1?: Ret<SubnetV6> } $r
	 */
	public function filter_subnet_v6(array $r, $value, ?string $ipFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$net->type_subnet_v6($value, $ipFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function filter_url(
		array $r,
		$value,
		$query = null,
		$fragment = null,
		?int $isHostIdnaAscii = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$url->type_url($value, $query, $fragment, $isHostIdnaAscii, $isLinkUrlencoded, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string|true $value
	 */
	public function filter_host(array $r, $value, ?int $isHostIdnaAscii = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$url->type_host($value, $isHostIdnaAscii, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param string|true             $value
	 * @param string|false|array|null $query
	 * @param string|false|null       $fragment
	 */
	public function filter_link(
		array $r,
		$value,
		$query = null,
		$fragment = null,
		?int $isLinkUrlencoded = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$url->type_link($value, $query, $fragment, $isLinkUrlencoded, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_uuid(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$random->type_uuid($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array|\Countable, 1?: Ret<array|\Countable> } $r
	 */
	public function filter_countable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_countable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \Countable, 1?: Ret<\Countable> } $r
	 */
	public function filter_countable_object(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_countable_object($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string|array|\Countable, 1?: Ret<string|array|\Countable> } $r
	 */
	public function filter_sizeable(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_sizeable($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone(array $r, $timezone, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_timezone($timezone, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_offset(array $r, $timezoneOrOffset): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_timezone_offset($timezoneOrOffset))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_abbr(array $r, $timezoneOrAbbr): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_timezone_abbr($timezoneOrAbbr))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_name(array $r, $timezoneOrName): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_timezone_name($timezoneOrName))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeZone, 1?: Ret<\DateTimeZone> } $r
	 */
	public function filter_timezone_nameabbr(array $r, $timezoneOrNameOrAbbr): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_timezone_nameabbr($timezoneOrNameOrAbbr))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date(array $r, $datestring, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_date($datestring, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate(array $r, $datestring, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_adate($datestring, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate(array $r, $datestring, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_idate($datestring, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_formatted(array $r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_date_formatted($dateFormatted, $formats, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_formatted(array $r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_adate_formatted($dateFormatted, $formats, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_formatted(array $r, $dateFormatted, $formats, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_idate_formatted($dateFormatted, $formats, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_tz(array $r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_date_tz($datestring, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_tz(array $r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_adate_tz($datestring, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_tz(array $r, $datestring, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_idate_tz($datestring, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_tz_formatted(array $r, $dateFormatted, $formats, ?array $allowedTimezoneTypes = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_date_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_tz_formatted(
		array $r,
		$dateFormatted,
		$formats,
		?array $allowedTimezoneTypes = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_adate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_tz_formatted(
		array $r,
		$dateFormatted,
		$formats,
		?array $allowedTimezoneTypes = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_idate_tz_formatted($dateFormatted, $formats, $allowedTimezoneTypes))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeInterface, 1?: Ret<\DateTimeInterface> } $r
	 */
	public function filter_date_microtime(array $r, $microtime, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_date_microtime($microtime, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTime, 1?: Ret<\DateTime> } $r
	 */
	public function filter_adate_microtime(array $r, $microtime, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_adate_microtime($microtime, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateTimeImmutable, 1?: Ret<\DateTimeImmutable> } $r
	 */
	public function filter_idate_microtime(array $r, $microtime, $timezoneFallback = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_idate_microtime($microtime, $timezoneFallback))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval(array $r, $interval): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_interval($interval))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_duration(array $r, $duration): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_interval_duration($duration))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_datestring(array $r, $datestring): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_interval_datestring($datestring))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_microtime(array $r, $microtime): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_interval_microtime($microtime))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \DateInterval, 1?: Ret<\DateInterval> } $r
	 */
	public function filter_interval_ago(array $r, $date, ?\DateTimeInterface $from = null, ?bool $reverse = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$date->type_interval_ago($date, $from, $reverse))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T, 1?: Ret<class-string<T> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_exists(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_exists($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T, 1?: Ret<class-string<T> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T, 1?: Ret<class-string<T> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_class(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_class($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string, 1?: Ret<class-string> } $r
	 */
	public function filter_struct_interface(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_interface($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string, 1?: Ret<class-string> } $r
	 */
	public function filter_struct_trait(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_trait($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T, 1?: Ret<class-string<T> } $r
	 *
	 * @template-covariant T of \UnitEnum
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_enum(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_enum($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: class-string<T, 1?: Ret<class-string<T> } $r
	 *
	 * @template-covariant T of object
	 * @param class-string<T>|T|mixed $value
	 */
	public function filter_struct_fqcn(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_fqcn($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_struct_namespace(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_namespace($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_struct_basename(array $r, $value, ?int $flags = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_struct_basename($value, $flags))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_resource(array $r, $value, ?string $resourceType = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_resource($value, $resourceType))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_resource_opened(array $r, $value, ?string $resourceType = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_resource_opened($value, $resourceType))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_resource_closed(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_resource_closed($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_any_not_resource(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_any_not_resource($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource|\CurlHandle, 1?: Ret<resource|\CurlHandle> } $r
	 */
	public function filter_curl(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_curl($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: T, 1?: Ret<T> } $r
	 *
	 * @template-covariant T of \UnitEnum
	 * @param T|int|string         $value
	 * @param class-string<T>|null $enumClass
	 */
	public function filter_enum_case(array $r, $value, ?string $enumClass = null): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_enum_case($value, $enumClass))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: array{ 0: class-string, 1: string }, 1?: Ret<array{ 0: class-string, 1: string }> } $r
	 */
	public function filter_method_array(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_method_array($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_method_string(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_method_string($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable, 1?: Ret<callable> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_object($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|\Closure|object, 1?: Ret<callable|\Closure|object> } $r
	 */
	public function filter_callable_object(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_object($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \Closure, 1?: Ret<\Closure> } $r
	 */
	public function filter_callable_object_closure(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_object_closure($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|object, 1?: Ret<callable|object> } $r
	 */
	public function filter_callable_object_invokable(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_object_invokable($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: object|class-string, 1: string }, 1?: Ret<callable|array{ 0: object|class-string, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_array($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: object|class-string, 1: string }, 1?: Ret<callable|array{ 0: object|class-string, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array_method(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_array_method($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: class-string, 1: string }, 1?: Ret<callable|array{ 0: class-string, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array_method_static(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_array_method_static($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable|array{ 0: object, 1: string }, 1?: Ret<callable|array{ 0: object, 1: string }> } $r
	 *
	 * @param string|object $newScope
	 */
	public function filter_callable_array_method_non_static(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_array_method_non_static($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable-string, 1?: Ret<callable-string> } $r
	 */
	public function filter_callable_string(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_string($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable-string, 1?: Ret<callable-string> } $r
	 */
	public function filter_callable_string_function(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_string_function($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable-string, 1?: Ret<callable-string> } $r
	 */
	public function filter_callable_string_function_internal(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_string_function_internal($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable-string, 1?: Ret<callable-string> } $r
	 */
	public function filter_callable_string_function_non_internal(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_string_function_non_internal($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: callable-string, 1?: Ret<callable-string> } $r
	 */
	public function filter_callable_string_method_static(array $r, $value, $newScope = 'static'): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$php->type_callable_string_method_static($value, $newScope))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: int, 1?: Ret<int> } $r
	 */
	public function filter_chmod(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_chmod($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_path(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_path($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_realpath(array $r, $value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_realpath($value, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_freepath(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_freepath($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_dirpath(
		array $r,
		$value,
		?bool $isAllowExists,
		?bool $isAllowSymlink = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_dirpath($value, $isAllowExists, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_filepath(
		array $r,
		$value,
		?bool $isAllowExists,
		?bool $isAllowSymlink = null,
		array $refs = []
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_filepath($value, $isAllowExists, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_dirpath_realpath(array $r, $value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_dirpath_realpath($value, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0: array|null } $refs
	 */
	public function filter_filepath_realpath(array $r, $value, ?bool $isAllowSymlink = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_filepath_realpath($value, $isAllowSymlink, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 */
	public function filter_filename(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_filename($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \SplFileInfo, 1?: Ret<\SplFileInfo> } $r
	 */
	public function filter_file(
		array $r,
		$value,
		?array $extensions = null,
		?array $mimeTypes = null,
		?array $filters = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_file($value, $extensions, $mimeTypes, $filters))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: \SplFileInfo, 1?: Ret<\SplFileInfo> } $r
	 */
	public function filter_image(
		array $r,
		$value,
		?array $extensions = null,
		?array $mimeTypes = null,
		?array $filters = null
	): bool {
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_image($value, $extensions, $mimeTypes, $filters))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource|\Socket, 1?: Ret<resource|\Socket> } $r
	 */
	public function filter_socket(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_socket($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: resource, 1?: Ret<resource> } $r
	 */
	public function filter_stream(array $r, $value): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$fs->type_stream($value))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_email(array $r, $value, ?array $filters = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_email($value, $filters, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_email_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_email_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_email_non_fake(array $r, $value, ?array $filters = null, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_email_non_fake($value, $filters, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_phone(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_phone($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_phone_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_phone_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_phone_non_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_phone_non_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string, 3?: string } $refs
	 */
	public function filter_phone_real(array $r, $value, ?string $region = '', array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_phone_real($value, $region, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_tel(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_tel($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string } $refs
	 */
	public function filter_tel_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_tel_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_tel_non_fake(array $r, $value, array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_tel_non_fake($value, $refs))->isOk([ &$refValue ]);
	}


	/**
	 * @param array{ 0?: string, 1?: Ret<string> } $r
	 *
	 * @param array{ 0?: string, 1?: string, 2?: string } $refs
	 */
	public function filter_tel_real(array $r, $value, ?string $region = '', array $refs = []): bool
	{
		if (array_key_exists(0, $r)) $refValue = &$r[ 0 ];
		if (array_key_exists(1, $r)) $refRet = &$r[ 1 ];
		return ($refRet = \Gzhegow\Lib\Lib::$social->type_tel_real($value, $region, $refs))->isOk([ &$refValue ]);
	}
}
